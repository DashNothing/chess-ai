{"version":3,"sources":["interfaces.ts","PrecomputedMoves.ts","PieceSquareTables.ts","GameLogic.ts","components/Board.tsx","components/GameInfo.tsx","components/PromotionModal.tsx","components/GameOverModal.tsx","App.tsx","AI.ts","index.tsx"],"names":["PieceType","Color","directionOffsets","allKnightJumps","numSquaresToEdge","rookMoves","bishopMoves","queenMoves","kingMoves","knightMoves","pawnCapturesWhite","pawnCapturesBlack","squareIndex","y","Math","floor","x","north","south","west","east","min","legalRookMoves","directionIndex","currentDirOffset","n","targetSquare","push","legalBishopMoves","legalQueenMoves","legalKingMoves","forEach","kingMoveDelta","kingMoveSquare","kingMoveSquareY","kingMoveSquareX","max","abs","legalKnightJumps","knightJumpDelta","knightJumpSquare","knightJumpSquareY","knightJumpSquareX","tempPawnCapturesWhite","tempPawnCapturesBlack","pawnPSTableB","pawnPSTableW","reverse","knightPSTableB","knightPSTableW","bishopPSTableB","bishopPSTableW","rookPSTableB","rookPSTableW","queenPSTableB","queenPSTableW","kingPSTableB","kingPSTableW","generatePseudoLegalMoves","gameState","pseudoLegalMoves","pieces","boardState","map","piece","index","filter","color","currentPlayer","type","Rook","fromSquare","toSquare","Bishop","Queen","Knight","King","allKingMoves","attackedSquares","getAttackedSquares","attackedSquare","kingMove","splice","indexOf","canCastleShort","White","castlingRights","whiteShort","blackShort","canCastleLong","whiteLong","blackLong","includes","Pawn","doubleMoveSquare","startingRank","captureSquare","generateLegalMoves","legalMoves","kingAttacks","getKingAttacks","length","movesWithKing","move","captures","isSlidingPiece","attackRay","getAttackRayToKing","blocks","attackRays","attackerSquare","ray","friendlyPiecesInRay","pinnedPieceSquare","square","illegalMove","opponentColor","Black","opponentPiece","getPieceAttackingSquares","myKingSquare","find","opponentPieces","startDir","endDir","foundKing","tempRaySquares","makeMove","newBoard","newCastlingRights","newCurrentPlayer","newEnPassantSquare","newHalfMoveClock","halfMoveClock","newFullMoves","fullMoves","movedPiece","isPawnMoveOrCapture","rookMove","isMoveCastling","rook","isMovePromotion","promotePawn","enPassantSquare","pawnSquare","promoteTo","gameStateFromFEN","fen","symbolToPiece","symbol","toLowerCase","fenArray","split","fenBoard","file","rank","isNaN","parseInt","toUpperCase","i","fenCastling","fenPassant","fileString","rankString","charCodeAt","fenHalfMove","fenFullMoves","evaluateMaterialAdvantage","side","piecePoints","myScore","opponentScore","table","materialPoints","positionPoints","Chessboard","styled","div","Square","props","row","isLight","isMarkedLegal","isMarkedLastMove","process","image","getImageForPiece","Board","lastMove","onMakeMove","useState","markedLegalMoveSquares","setMarkedLegalMoveSquares","boardTiles","key","onDragOver","e","onDrop","style","position","top","left","draggable","onDragStart","onDragEnd","preventDefault","tilePos","a","currentTarget","opacity","dataTransfer","setData","toString","dragImage","Image","src","setDragImage","allLegalMoves","tilePosition","getData","Wrapper","aside","GameInfo","fenString","pieceToSymbol","rankIndex","emptySquares","fileIndex","String","fromCharCode","FENFromGameState","appearAnimation","keyframes","Container","PromotionModal","isShowing","onSelect","animationDelay","onClick","GameOverModal","winner","onRestart","transform","startingFEN","main","App","setGameState","setLastMove","isPromotionModalShowing","setIsPromotionModalShowing","isGameOverModalShowing","setIsGameOverModalShowing","setWinner","squareToPromote","setSquareToPromote","useEffect","computerMove","startTime","positionCounter","alphaBeta","alpha","beta","depth","movesToEvaluate","score","bestMovesWithScores","bestMoveScore","Number","POSITIVE_INFINITY","Date","now","moveScore","NEGATIVE_INFINITY","timeDiff","console","log","random","getAlphaBetaMove","callMakeMove","newGameState","selectedPiece","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fff71146.chunk.js","sourcesContent":["export enum PieceType {\r\n\tKing,\r\n\tQueen,\r\n\tRook,\r\n\tBishop,\r\n\tKnight,\r\n\tPawn,\r\n}\r\n\r\nexport enum Color {\r\n\tWhite,\r\n\tBlack,\r\n}\r\n\r\nexport interface Piece {\r\n\ttype: PieceType;\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface Move {\r\n\tfromSquare: number;\r\n\ttoSquare: number;\r\n}\r\n\r\nexport interface CastlingRights {\r\n\twhiteShort: boolean;\r\n\twhiteLong: boolean;\r\n\tblackShort: boolean;\r\n\tblackLong: boolean;\r\n}\r\n\r\nexport interface GameState {\r\n\tboardState: (Piece | null)[];\r\n\tcurrentPlayer: Color;\r\n\tcastlingRights: CastlingRights;\r\n\tenPassantSquare: number | null;\r\n\thalfMoveClock: number;\r\n\tfullMoves: number;\r\n}\r\n","import { Move } from \"./interfaces\";\r\n\r\n// First 4 are orthogonal, last 4 are diagonal\r\nconst directionOffsets = [8, -8, -1, 1, 7, -7, 9, -9];\r\n\r\nconst allKnightJumps: number[] = [15, 17, -17, -15, 10, -6, 6, -10];\r\n\r\nlet numSquaresToEdge: [number[]] = [[]];\r\n\r\nlet rookMoves: number[][] = [];\r\nlet bishopMoves: number[][] = [[]];\r\nlet queenMoves: number[][] = [[]];\r\nlet kingMoves: number[][] = [];\r\nlet knightMoves: number[][] = [];\r\nlet pawnCapturesWhite: number[][] = [[]];\r\nlet pawnCapturesBlack: number[][] = [[]];\r\n\r\nfor (let squareIndex = 0; squareIndex < 64; squareIndex++) {\r\n\tlet y: number = Math.floor(squareIndex / 8);\r\n\tlet x: number = squareIndex - y * 8;\r\n\r\n\tlet north: number = 7 - y;\r\n\tlet south: number = y;\r\n\tlet west: number = x;\r\n\tlet east: number = 7 - x;\r\n\r\n\tnumSquaresToEdge[squareIndex] = [];\r\n\r\n\tnumSquaresToEdge[squareIndex][0] = north;\r\n\tnumSquaresToEdge[squareIndex][1] = south;\r\n\tnumSquaresToEdge[squareIndex][2] = west;\r\n\tnumSquaresToEdge[squareIndex][3] = east;\r\n\tnumSquaresToEdge[squareIndex][4] = Math.min(north, west);\r\n\tnumSquaresToEdge[squareIndex][5] = Math.min(south, east);\r\n\tnumSquaresToEdge[squareIndex][6] = Math.min(north, east);\r\n\tnumSquaresToEdge[squareIndex][7] = Math.min(south, west);\r\n\r\n\t// Rook moves\r\n\tlet legalRookMoves: number[] = [];\r\n\tfor (let directionIndex = 0; directionIndex < 4; directionIndex++) {\r\n\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\tfor (let n = 0; n < numSquaresToEdge[squareIndex][directionIndex]; n++) {\r\n\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\t\t\tlegalRookMoves.push(targetSquare);\r\n\t\t}\r\n\t}\r\n\trookMoves[squareIndex] = legalRookMoves;\r\n\r\n\t// Bishop moves\r\n\tlet legalBishopMoves: number[] = [];\r\n\tfor (let directionIndex = 4; directionIndex < 8; directionIndex++) {\r\n\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\tfor (let n = 0; n < numSquaresToEdge[squareIndex][directionIndex]; n++) {\r\n\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\t\t\tlegalBishopMoves.push(targetSquare);\r\n\t\t}\r\n\t}\r\n\tbishopMoves[squareIndex] = legalBishopMoves;\r\n\r\n\t// Queen moves\r\n\tlet legalQueenMoves: number[] = [];\r\n\tfor (let directionIndex = 0; directionIndex < 8; directionIndex++) {\r\n\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\tfor (let n = 0; n < numSquaresToEdge[squareIndex][directionIndex]; n++) {\r\n\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\t\t\tlegalQueenMoves.push(targetSquare);\r\n\t\t}\r\n\t}\r\n\tqueenMoves[squareIndex] = legalQueenMoves;\r\n\r\n\t// King moves\r\n\tlet legalKingMoves: number[] = [];\r\n\tdirectionOffsets.forEach((kingMoveDelta) => {\r\n\t\tlet kingMoveSquare: number = squareIndex + kingMoveDelta;\r\n\t\t// Check only moves within the bounds of the board\r\n\t\tif (kingMoveSquare >= 0 && kingMoveSquare < 64) {\r\n\t\t\tlet kingMoveSquareY = Math.floor(kingMoveSquare / 8);\r\n\t\t\tlet kingMoveSquareX = kingMoveSquare - kingMoveSquareY * 8;\r\n\t\t\t// Save only moves that didn't wrap around the board (where max move distance in any direction is 1)\r\n\t\t\tlet maxMoveDistance = Math.max(\r\n\t\t\t\tMath.abs(x - kingMoveSquareX),\r\n\t\t\t\tMath.abs(y - kingMoveSquareY)\r\n\t\t\t);\r\n\t\t\tif (maxMoveDistance === 1) {\r\n\t\t\t\tlegalKingMoves.push(kingMoveSquare);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tkingMoves[squareIndex] = legalKingMoves;\r\n\r\n\t// Knight moves\r\n\tlet legalKnightJumps: number[] = [];\r\n\tallKnightJumps.forEach((knightJumpDelta) => {\r\n\t\tlet knightJumpSquare = squareIndex + knightJumpDelta;\r\n\t\t// Check only moves within the bounds of the board\r\n\t\tif (knightJumpSquare >= 0 && knightJumpSquare < 64) {\r\n\t\t\tlet knightJumpSquareY = Math.floor(knightJumpSquare / 8);\r\n\t\t\tlet knightJumpSquareX = knightJumpSquare - knightJumpSquareY * 8;\r\n\t\t\t// Save only moves that didn't wrap around the board (where max move distance in any direction is 2)\r\n\t\t\tlet maxMoveDistance = Math.max(\r\n\t\t\t\tMath.abs(x - knightJumpSquareX),\r\n\t\t\t\tMath.abs(y - knightJumpSquareY)\r\n\t\t\t);\r\n\t\t\tif (maxMoveDistance === 2) {\r\n\t\t\t\tlegalKnightJumps.push(knightJumpSquare);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tknightMoves[squareIndex] = legalKnightJumps;\r\n\r\n\t// Pawn captures\r\n\t// Calculate legal pawn captures for white and black\r\n\tlet tempPawnCapturesWhite: number[] = [];\r\n\tlet tempPawnCapturesBlack: number[] = [];\r\n\tif (x > 0) {\r\n\t\tif (y < 7) {\r\n\t\t\ttempPawnCapturesWhite.push(squareIndex + 7);\r\n\t\t}\r\n\t\tif (y > 0) {\r\n\t\t\ttempPawnCapturesBlack.push(squareIndex - 9);\r\n\t\t}\r\n\t}\r\n\tif (x < 7) {\r\n\t\tif (y < 7) {\r\n\t\t\ttempPawnCapturesWhite.push(squareIndex + 9);\r\n\t\t}\r\n\t\tif (y > 0) {\r\n\t\t\ttempPawnCapturesBlack.push(squareIndex - 7);\r\n\t\t}\r\n\t}\r\n\r\n\tpawnCapturesWhite[squareIndex] = tempPawnCapturesWhite;\r\n\tpawnCapturesBlack[squareIndex] = tempPawnCapturesBlack;\r\n}\r\n\r\nexport {\r\n\tnumSquaresToEdge,\r\n\trookMoves,\r\n\tbishopMoves,\r\n\tqueenMoves,\r\n\tkingMoves,\r\n\tknightMoves,\r\n\tpawnCapturesBlack,\r\n\tpawnCapturesWhite,\r\n};\r\n","// prettier-ignore\r\nexport const pawnPSTableB = [\r\n  0,  0,  0,  0,  0,  0,  0,  0,\r\n  50, 50, 50, 50, 50, 50, 50, 50,\r\n  10, 10, 20, 30, 30, 20, 10, 10,\r\n  5,  5, 10, 25, 25, 10,  5,  5,\r\n  0,  0,  0, 20, 20,  0,  0,  0,\r\n  5, -5,-10,  0,  0,-10, -5,  5,\r\n  5, 10, 10,-20,-20, 10, 10,  5,\r\n  0,  0,  0,  0,  0,  0,  0,  0,\r\n]\r\n\r\nexport const pawnPSTableW = [...pawnPSTableB].reverse();\r\n\r\n// prettier-ignore\r\nexport const knightPSTableB = [\r\n  -50,-40,-30,-30,-30,-30,-40,-50,\r\n  -40,-20,  0,  0,  0,  0,-20,-40,\r\n  -30,  0, 10, 15, 15, 10,  0,-30,\r\n  -30,  5, 15, 20, 20, 15,  5,-30,\r\n  -30,  0, 15, 20, 20, 15,  0,-30,\r\n  -30,  5, 10, 15, 15, 10,  5,-30,\r\n  -40,-20,  0,  5,  5,  0,-20,-40,\r\n  -50,-40,-30,-30,-30,-30,-40,-50,\r\n];\r\n\r\nexport const knightPSTableW = [...knightPSTableB].reverse();\r\n\r\n// prettier-ignore\r\nexport const bishopPSTableB = [\r\n  -20,-10,-10,-10,-10,-10,-10,-20,\r\n  -10,  0,  0,  0,  0,  0,  0,-10,\r\n  -10,  0,  5, 10, 10,  5,  0,-10,\r\n  -10,  5,  5, 10, 10,  5,  5,-10,\r\n  -10,  0, 10, 10, 10, 10,  0,-10,\r\n  -10, 10, 10, 10, 10, 10, 10,-10,\r\n  -10,  5,  0,  0,  0,  0,  5,-10,\r\n  -20,-10,-10,-10,-10,-10,-10,-20,\r\n]\r\n\r\nexport const bishopPSTableW = [...bishopPSTableB].reverse();\r\n\r\n// prettier-ignore\r\nexport const rookPSTableB = [\r\n  0,  0,  0,  0,  0,  0,  0,  0,\r\n  5, 10, 10, 10, 10, 10, 10,  5,\r\n -5,  0,  0,  0,  0,  0,  0, -5,\r\n -5,  0,  0,  0,  0,  0,  0, -5,\r\n -5,  0,  0,  0,  0,  0,  0, -5,\r\n -5,  0,  0,  0,  0,  0,  0, -5,\r\n -5,  0,  0,  0,  0,  0,  0, -5,\r\n  0,  0,  0,  5,  5,  0,  0,  0\r\n]\r\n\r\nexport const rookPSTableW = [...rookPSTableB].reverse();\r\n\r\n// prettier-ignore\r\nexport const queenPSTableB = [\r\n  -20,-10,-10, -5, -5,-10,-10,-20,\r\n  -10,  0,  0,  0,  0,  0,  0,-10,\r\n  -10,  0,  5,  5,  5,  5,  0,-10,\r\n  -5,  0,  5,  5,  5,  5,  0, -5,\r\n    0,  0,  5,  5,  5,  5,  0, -5,\r\n  -10,  5,  5,  5,  5,  5,  0,-10,\r\n  -10,  0,  5,  0,  0,  0,  0,-10,\r\n  -20,-10,-10, -5, -5,-10,-10,-20\r\n]\r\n\r\nexport const queenPSTableW = [...queenPSTableB].reverse();\r\n\r\n// prettier-ignore\r\nexport const kingPSTableB = [\r\n  -30,-40,-40,-50,-50,-40,-40,-30,\r\n  -30,-40,-40,-50,-50,-40,-40,-30,\r\n  -30,-40,-40,-50,-50,-40,-40,-30,\r\n  -30,-40,-40,-50,-50,-40,-40,-30,\r\n  -20,-30,-30,-40,-40,-30,-30,-20,\r\n  -10,-20,-20,-20,-20,-20,-20,-10,\r\n  20, 20,  0,  0,  0,  0, 20, 20,\r\n  20, 30, 10,  0,  0, 10, 30, 20\r\n]\r\n\r\nexport const kingPSTableW = [...kingPSTableB].reverse();\r\n","import {\r\n\tMove,\r\n\tPiece,\r\n\tColor,\r\n\tPieceType,\r\n\tCastlingRights,\r\n\tGameState,\r\n} from \"./interfaces\";\r\nimport {\r\n\tnumSquaresToEdge,\r\n\tkingMoves,\r\n\tknightMoves,\r\n\tpawnCapturesWhite,\r\n\tpawnCapturesBlack,\r\n} from \"./PrecomputedMoves\";\r\nimport {\r\n\tpawnPSTableB,\r\n\tknightPSTableB,\r\n\tbishopPSTableB,\r\n\trookPSTableB,\r\n\tqueenPSTableB,\r\n\tkingPSTableB,\r\n\tpawnPSTableW,\r\n\tknightPSTableW,\r\n\tbishopPSTableW,\r\n\trookPSTableW,\r\n\tqueenPSTableW,\r\n\tkingPSTableW,\r\n} from \"./PieceSquareTables\";\r\n\r\nvar attackMoves: { piece: Piece; squares: number[] }[] = [];\r\n\r\n/*\r\n\tGenerates moves without check detection\r\n\tReturns a list of all pesudo legal moves\r\n*/\r\nexport const generatePseudoLegalMoves = (gameState: GameState): Move[] => {\r\n\tlet pseudoLegalMoves: Move[] = [];\r\n\r\n\tlet pieces: [Piece | null, number][] = gameState.boardState.map(\r\n\t\t(piece, index) => [piece, index]\r\n\t);\r\n\r\n\tpieces = pieces.filter(\r\n\t\t([piece, index]) => piece?.color === gameState.currentPlayer\r\n\t);\r\n\r\n\t// First 4 are orthogonal, last 4 are diagonals (N, S, W, E, NW, SE, NE, SW)\r\n\tconst directionOffsets = [8, -8, -1, 1, 7, -7, 9, -9];\r\n\r\n\tpieces.forEach(([piece, squareIndex]) => {\r\n\t\tswitch (piece?.type) {\r\n\t\t\tcase PieceType.Rook: {\r\n\t\t\t\tfor (let directionIndex = 0; directionIndex < 4; directionIndex++) {\r\n\t\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\t\tfor (\r\n\t\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\t\tn++\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\t\tif (gameState.boardState[targetSquare]?.color === piece?.color) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tgameState.boardState[targetSquare] != null &&\r\n\t\t\t\t\t\t\tgameState.boardState[targetSquare]?.color !== piece?.color\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.Bishop: {\r\n\t\t\t\tfor (let directionIndex = 4; directionIndex < 8; directionIndex++) {\r\n\t\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\t\tfor (\r\n\t\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\t\tn++\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\t\tif (gameState.boardState[targetSquare]?.color === piece?.color) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tgameState.boardState[targetSquare] != null &&\r\n\t\t\t\t\t\t\tgameState.boardState[targetSquare]?.color !== piece?.color\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.Queen: {\r\n\t\t\t\tfor (let directionIndex = 0; directionIndex < 8; directionIndex++) {\r\n\t\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\t\tfor (\r\n\t\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\t\tn++\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tgameState.boardState[targetSquare]?.color ===\r\n\t\t\t\t\t\t\tgameState.currentPlayer\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tgameState.boardState[targetSquare] != null &&\r\n\t\t\t\t\t\t\tgameState.boardState[targetSquare]?.color !==\r\n\t\t\t\t\t\t\t\tgameState.currentPlayer\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.Knight: {\r\n\t\t\t\t// Find all knight moves from the piece's square\r\n\t\t\t\tlet allKnightMoves = knightMoves[squareIndex];\r\n\r\n\t\t\t\t// Filter out the moves that land on friendly pieces\r\n\t\t\t\tallKnightMoves.forEach((targetSquare) => {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tgameState.boardState[targetSquare]?.color !==\r\n\t\t\t\t\t\tgameState.currentPlayer\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.King: {\r\n\t\t\t\t// Find all king moves from the piece's square\r\n\t\t\t\tlet allKingMoves = [...kingMoves[squareIndex]];\r\n\r\n\t\t\t\t// Don't add moves that are under attack\r\n\t\t\t\tconst attackedSquares = getAttackedSquares(gameState);\r\n\t\t\t\tfor (let attackedSquare of attackedSquares) {\r\n\t\t\t\t\tfor (let kingMove of allKingMoves)\r\n\t\t\t\t\t\tif (kingMove === attackedSquare) {\r\n\t\t\t\t\t\t\tallKingMoves.splice(allKingMoves.indexOf(kingMove), 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Filter out the moves that land on friendly pieces\r\n\t\t\t\tallKingMoves.forEach((targetSquare) => {\r\n\t\t\t\t\tif (gameState.boardState[targetSquare]?.color !== piece?.color) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Castling\r\n\t\t\t\tconst canCastleShort =\r\n\t\t\t\t\tgameState.currentPlayer === Color.White\r\n\t\t\t\t\t\t? gameState.castlingRights.whiteShort\r\n\t\t\t\t\t\t: gameState.castlingRights.blackShort;\r\n\r\n\t\t\t\tconst canCastleLong =\r\n\t\t\t\t\tgameState.currentPlayer === Color.White\r\n\t\t\t\t\t\t? gameState.castlingRights.whiteLong\r\n\t\t\t\t\t\t: gameState.castlingRights.blackLong;\r\n\r\n\t\t\t\tif (canCastleShort) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tgameState.boardState[squareIndex + 1] == null &&\r\n\t\t\t\t\t\tgameState.boardState[squareIndex + 2] == null &&\r\n\t\t\t\t\t\t!attackedSquares.includes(squareIndex + 1) &&\r\n\t\t\t\t\t\t!attackedSquares.includes(squareIndex + 2)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: squareIndex + 2,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (canCastleLong) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tgameState.boardState[squareIndex - 1] == null &&\r\n\t\t\t\t\t\tgameState.boardState[squareIndex - 2] == null &&\r\n\t\t\t\t\t\t!attackedSquares.includes(squareIndex - 1) &&\r\n\t\t\t\t\t\t!attackedSquares.includes(squareIndex - 2)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: squareIndex - 2,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.Pawn: {\r\n\t\t\t\t// Single moves\r\n\t\t\t\tlet targetSquare =\r\n\t\t\t\t\tpiece.color === Color.White ? squareIndex + 8 : squareIndex - 8;\r\n\r\n\t\t\t\tif (targetSquare >= 0 && targetSquare < 64) {\r\n\t\t\t\t\tif (gameState.boardState[targetSquare] == null)\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Double first move\r\n\t\t\t\tlet doubleMoveSquare =\r\n\t\t\t\t\tpiece.color === Color.White ? squareIndex + 16 : squareIndex - 16;\r\n\t\t\t\tlet startingRank = piece.color === Color.White ? 1 : 6;\r\n\r\n\t\t\t\tif (Math.floor(squareIndex / 8) === startingRank) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tgameState.boardState[targetSquare] == null &&\r\n\t\t\t\t\t\tgameState.boardState[doubleMoveSquare] == null\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: doubleMoveSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Pawn captures\r\n\t\t\t\tlet pawnCaptures: number[] = [];\r\n\t\t\t\tif (piece.color === Color.White) {\r\n\t\t\t\t\tpawnCaptures = pawnCapturesWhite[squareIndex];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpawnCaptures = pawnCapturesBlack[squareIndex];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpawnCaptures.forEach((captureSquare) => {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tgameState.boardState[captureSquare]?.color !==\r\n\t\t\t\t\t\t\tgameState.currentPlayer &&\r\n\t\t\t\t\t\tgameState.boardState[captureSquare] != null\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: captureSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t});\r\n\r\n\treturn pseudoLegalMoves;\r\n};\r\n\r\n/*\r\n\tGenerates the moves with check detecion by generating pseudo legal moves and removing illegal moves\r\n\tReturns a list of all legal moves\r\n*/\r\nexport const generateLegalMovesSlow = (gameState: GameState): Move[] => {\r\n\tlet legalMoves: Move[] = [];\r\n\tlet pseudoLegalMoves: Move[] = generatePseudoLegalMoves(gameState);\r\n\r\n\tpseudoLegalMoves.forEach((move) => {\r\n\t\tconst gameStateAfterMove = makeMove(gameState, move);\r\n\t\tconst opponentResponses = generatePseudoLegalMoves(gameStateAfterMove);\r\n\r\n\t\tlet myKingSquare = gameStateAfterMove.boardState.indexOf(\r\n\t\t\tgameStateAfterMove.boardState.find(\r\n\t\t\t\t(piece) =>\r\n\t\t\t\t\tpiece?.type === PieceType.King &&\r\n\t\t\t\t\tpiece?.color === gameState.currentPlayer\r\n\t\t\t) || null\r\n\t\t);\r\n\r\n\t\tif (\r\n\t\t\topponentResponses.some(\r\n\t\t\t\t(responseMove) => responseMove.toSquare === myKingSquare\r\n\t\t\t)\r\n\t\t) {\r\n\t\t} else {\r\n\t\t\tlegalMoves.push(move);\r\n\t\t}\r\n\t});\r\n\r\n\treturn legalMoves;\r\n};\r\n\r\n/*\r\n\tGenerates legal moves in an optimized way, using lists of attacked squares\r\n\tReturns a list of all legal moves\r\n*/\r\nexport const generateLegalMoves = (gameState: GameState): Move[] => {\r\n\tlet pseudoLegalMoves: Move[] = generatePseudoLegalMoves(gameState);\r\n\tlet legalMoves: Move[] = [];\r\n\r\n\tconst kingAttacks = getKingAttacks(gameState);\r\n\r\n\t// If king is in check\r\n\tif (kingAttacks.length > 0) {\r\n\t\tif (kingAttacks.length == 1) {\r\n\t\t\t// Single check, can do only 3 things:\r\n\t\t\t// 1. move the king out of the check\r\n\t\t\tconst movesWithKing = pseudoLegalMoves.filter(\r\n\t\t\t\t(move) => gameState.boardState[move.fromSquare]?.type === PieceType.King\r\n\t\t\t);\r\n\t\t\t// 2. capture the checking piece\r\n\t\t\tconst captures = pseudoLegalMoves.filter(\r\n\t\t\t\t(move) => move.toSquare === gameState.boardState.indexOf(kingAttacks[0])\r\n\t\t\t);\r\n\t\t\t// 3. block the check if the checking piece is queen, rook or bishop\r\n\t\t\tif (isSlidingPiece(kingAttacks[0].type)) {\r\n\t\t\t\t// Get the attacking piece's attack ray toward the king\r\n\t\t\t\tconst attackRay: number[] = getAttackRayToKing(\r\n\t\t\t\t\tkingAttacks[0],\r\n\t\t\t\t\tgameState\r\n\t\t\t\t);\r\n\t\t\t\t// Get the moves that end in the attack ray squares\r\n\t\t\t\tconst blocks = pseudoLegalMoves.filter((move) =>\r\n\t\t\t\t\tattackRay.includes(move.toSquare)\r\n\t\t\t\t);\r\n\t\t\t\tlegalMoves.push(...blocks);\r\n\t\t\t}\r\n\r\n\t\t\tlegalMoves.push(...movesWithKing);\r\n\t\t\tlegalMoves.push(...captures);\r\n\t\t} else {\r\n\t\t\t// Double check\r\n\t\t\t// Only king moves are allowed\r\n\t\t\tlegalMoves = pseudoLegalMoves.filter(\r\n\t\t\t\t(move) => gameState.boardState[move.fromSquare]?.type === PieceType.King\r\n\t\t\t);\r\n\t\t}\r\n\t} else {\r\n\t\t// If king is not in check we need to find pinned pieces and remove\r\n\t\t// any moves that move outside of the line between the attacker and the king\r\n\t\tlegalMoves = pseudoLegalMoves;\r\n\r\n\t\t// Only sliding pieces can pin other pieces\r\n\t\tconst opponentSlidingPieces = gameState.boardState.filter(\r\n\t\t\t(piece) =>\r\n\t\t\t\tpiece &&\r\n\t\t\t\tpiece.color !== gameState.currentPlayer &&\r\n\t\t\t\tisSlidingPiece(piece.type)\r\n\t\t);\r\n\r\n\t\t// Get all the attack rays from opponent sliding pieces to the king\r\n\t\tconst attackRays: { attackerSquare: number; ray: number[] }[] =\r\n\t\t\topponentSlidingPieces.map((piece) => {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tattackerSquare: gameState.boardState.indexOf(piece),\r\n\t\t\t\t\tray: getAttackRayToKing(piece!, gameState),\r\n\t\t\t\t};\r\n\t\t\t});\r\n\r\n\t\t// If any attack ray goes through only one friendly piece and the king,\r\n\t\t// that piece can only move inside the ray\r\n\t\tfor (const attackRay of attackRays) {\r\n\t\t\tlet friendlyPiecesInRay = 0;\r\n\t\t\tlet pinnedPieceSquare: number;\r\n\t\t\tattackRay.ray.forEach((square) => {\r\n\t\t\t\tif (gameState.boardState[square]?.color === gameState.currentPlayer) {\r\n\t\t\t\t\tfriendlyPiecesInRay++;\r\n\t\t\t\t\t// If first piece in the ray it's the pinned piece\r\n\t\t\t\t\tif (friendlyPiecesInRay == 1) {\r\n\t\t\t\t\t\tpinnedPieceSquare = square;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (friendlyPiecesInRay == 2) {\r\n\t\t\t\tconst pinnedPieceMoves = legalMoves.filter(\r\n\t\t\t\t\t(move) => move.fromSquare == pinnedPieceSquare\r\n\t\t\t\t);\r\n\r\n\t\t\t\tconst illegalPinnedPieceMoves = pinnedPieceMoves.filter(\r\n\t\t\t\t\t(move) =>\r\n\t\t\t\t\t\t!attackRay.ray.includes(move.toSquare) &&\r\n\t\t\t\t\t\tmove.toSquare !== attackRay.attackerSquare\r\n\t\t\t\t);\r\n\r\n\t\t\t\tillegalPinnedPieceMoves.forEach((illegalMove) => {\r\n\t\t\t\t\tlegalMoves.splice(legalMoves.indexOf(illegalMove), 1);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn legalMoves;\r\n};\r\n\r\n/*\r\n\tReturns the indeces of squares that the opposing player is attacking\r\n*/\r\nconst getAttackedSquares = (gameState: GameState): number[] => {\r\n\tvar attackedSquares: number[] = [];\r\n\r\n\tconst opponentColor =\r\n\t\tgameState.currentPlayer === Color.White ? Color.Black : Color.White;\r\n\r\n\tconst opponentPieces: Piece[] = gameState.boardState\r\n\t\t.filter((piece) => piece != null && piece?.color === opponentColor)\r\n\t\t.map((piece) => piece!);\r\n\r\n\t// For every opponent piece get all the squares they attack\r\n\topponentPieces.forEach((opponentPiece) => {\r\n\t\tattackedSquares.push(\r\n\t\t\t...getPieceAttackingSquares(\r\n\t\t\t\tgameState,\r\n\t\t\t\topponentPiece,\r\n\t\t\t\tgameState.boardState.indexOf(opponentPiece)\r\n\t\t\t)\r\n\t\t);\r\n\t});\r\n\r\n\treturn attackedSquares;\r\n};\r\n\r\n/*\r\n\tTakes a piece\r\n\tReturns a list of all indeces attacked by the piece\r\n*/\r\nconst getPieceAttackingSquares = (\r\n\tgameState: GameState,\r\n\tpiece: Piece,\r\n\tsquareIndex: number\r\n): number[] => {\r\n\tlet attackedSquares: number[] = [];\r\n\r\n\t// First 4 are orthogonal, last 4 are diagonals (N, S, W, E, NW, SE, NE, SW)\r\n\tconst directionOffsets = [8, -8, -1, 1, 7, -7, 9, -9];\r\n\r\n\tswitch (piece?.type) {\r\n\t\tcase PieceType.Rook: {\r\n\t\t\tfor (let directionIndex = 0; directionIndex < 4; directionIndex++) {\r\n\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\tfor (\r\n\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\tn++\r\n\t\t\t\t) {\r\n\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\tattackedSquares.push(targetSquare);\r\n\r\n\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\tif (gameState.boardState[targetSquare]?.color === piece?.color) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t// If it's a king, don't stop\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tgameState.boardState[targetSquare] != null &&\r\n\t\t\t\t\t\tgameState.boardState[targetSquare]?.color !== piece?.color &&\r\n\t\t\t\t\t\tgameState.boardState[targetSquare]?.type !== PieceType.King\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase PieceType.Bishop: {\r\n\t\t\tfor (let directionIndex = 4; directionIndex < 8; directionIndex++) {\r\n\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\tfor (\r\n\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\tn++\r\n\t\t\t\t) {\r\n\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\tattackedSquares.push(targetSquare);\r\n\r\n\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\tif (gameState.boardState[targetSquare]?.color === piece?.color) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t// If it's a king, don't stop\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tgameState.boardState[targetSquare] != null &&\r\n\t\t\t\t\t\tgameState.boardState[targetSquare]?.color !== piece?.color &&\r\n\t\t\t\t\t\tgameState.boardState[targetSquare]?.type !== PieceType.King\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase PieceType.Queen: {\r\n\t\t\tfor (let directionIndex = 0; directionIndex < 8; directionIndex++) {\r\n\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\tfor (\r\n\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\tn++\r\n\t\t\t\t) {\r\n\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\tattackedSquares.push(targetSquare);\r\n\r\n\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\tif (gameState.boardState[targetSquare]?.color === piece?.color) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t// If it's a king, don't stop\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tgameState.boardState[targetSquare] != null &&\r\n\t\t\t\t\t\tgameState.boardState[targetSquare]?.color !== piece?.color &&\r\n\t\t\t\t\t\tgameState.boardState[targetSquare]?.type !== PieceType.King\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase PieceType.Knight: {\r\n\t\t\t// Find all knight moves from the piece's square\r\n\t\t\tlet allKnightMoves = knightMoves[squareIndex];\r\n\r\n\t\t\t// Filter out the moves that land on friendly pieces\r\n\t\t\tallKnightMoves.forEach((targetSquare) => {\r\n\t\t\t\tattackedSquares.push(targetSquare);\r\n\t\t\t});\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase PieceType.Pawn: {\r\n\t\t\t// Pawn captures\r\n\t\t\tlet pawnCaptures: number[] = [];\r\n\t\t\tif (piece.color === Color.White) {\r\n\t\t\t\tpawnCaptures = pawnCapturesWhite[squareIndex];\r\n\t\t\t} else {\r\n\t\t\t\tpawnCaptures = pawnCapturesBlack[squareIndex];\r\n\t\t\t}\r\n\r\n\t\t\tpawnCaptures.forEach((captureSquare) => {\r\n\t\t\t\tattackedSquares.push(captureSquare);\r\n\t\t\t});\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase PieceType.King: {\r\n\t\t\t// Find all king moves from the piece's square\r\n\t\t\tlet allKingMoves = [...kingMoves[squareIndex]];\r\n\r\n\t\t\t// Filter out the moves that land on friendly pieces\r\n\t\t\tallKingMoves.forEach((targetSquare) => {\r\n\t\t\t\tattackedSquares.push(targetSquare);\r\n\t\t\t});\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn attackedSquares;\r\n};\r\n\r\n/*\r\n\tReturns a list of all pieces attacking the current player's king\r\n*/\r\nexport const getKingAttacks = (gameState: GameState): Piece[] => {\r\n\tlet kingAttacks: Piece[] = [];\r\n\r\n\tconst myKingSquare = gameState.boardState.indexOf(\r\n\t\tgameState.boardState.find(\r\n\t\t\t(piece) =>\r\n\t\t\t\tpiece?.type == PieceType.King && piece?.color == gameState.currentPlayer\r\n\t\t)!\r\n\t);\r\n\r\n\tconst opponentColor =\r\n\t\tgameState.currentPlayer === Color.White ? Color.Black : Color.White;\r\n\r\n\tconst opponentPieces: Piece[] = gameState.boardState\r\n\t\t.filter((piece) => piece != null && piece?.color === opponentColor)\r\n\t\t.map((piece) => piece!);\r\n\r\n\tfor (let opponentPiece of opponentPieces) {\r\n\t\tconst attackedSquares = getPieceAttackingSquares(\r\n\t\t\tgameState,\r\n\t\t\topponentPiece,\r\n\t\t\tgameState.boardState.indexOf(opponentPiece)\r\n\t\t);\r\n\r\n\t\tfor (let square of attackedSquares) {\r\n\t\t\tif (square === myKingSquare) {\r\n\t\t\t\tkingAttacks.push(opponentPiece!);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn kingAttacks;\r\n};\r\n\r\n/*\r\n\tReturns a list of all attacked squares in a ray toward the current player's king\r\n*/\r\nconst getAttackRayToKing = (piece: Piece, gameState: GameState): number[] => {\r\n\tlet attackRay: number[] = [];\r\n\r\n\tconst squareIndex = gameState.boardState.indexOf(piece);\r\n\r\n\t// First 4 are orthogonal, last 4 are diagonals (N, S, W, E, NW, SE, NE, SW)\r\n\tconst directionOffsets = [8, -8, -1, 1, 7, -7, 9, -9];\r\n\tconst startDir = piece.type === PieceType.Bishop ? 4 : 0;\r\n\tconst endDir = piece.type === PieceType.Rook ? 4 : 8;\r\n\r\n\t// Check every direction and save the attack ray where the current player's king is found\r\n\tfor (\r\n\t\tlet directionIndex = startDir;\r\n\t\tdirectionIndex < endDir;\r\n\t\tdirectionIndex++\r\n\t) {\r\n\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\tlet foundKing = false;\r\n\t\tlet tempRaySquares = [];\r\n\t\tfor (let n = 0; n < numSquaresToEdge[squareIndex][directionIndex]; n++) {\r\n\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\tif (gameState.boardState[targetSquare]?.color === piece?.color) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\ttempRaySquares.push(targetSquare);\r\n\r\n\t\t\t// If it's a king this is the right ray\r\n\t\t\tif (\r\n\t\t\t\tgameState.boardState[targetSquare] != null &&\r\n\t\t\t\tgameState.boardState[targetSquare]?.color !== piece?.color &&\r\n\t\t\t\tgameState.boardState[targetSquare]?.type === PieceType.King\r\n\t\t\t) {\r\n\t\t\t\tfoundKing = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (foundKing) {\r\n\t\t\tattackRay = [...tempRaySquares];\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn attackRay;\r\n};\r\n\r\n/*\r\n\tTakes a game state and a move\r\n\tReturns a modified game state based on the provied move\r\n*/\r\nexport const makeMove = (gameState: GameState, move: Move): GameState => {\r\n\tlet newBoard: (Piece | null)[] = [...gameState.boardState];\r\n\tlet newCastlingRights: CastlingRights = { ...gameState.castlingRights };\r\n\tlet newCurrentPlayer: Color = gameState.currentPlayer;\r\n\tlet newEnPassantSquare: number | null = null;\r\n\tlet newHalfMoveClock: number = gameState.halfMoveClock;\r\n\tlet newFullMoves: number = gameState.fullMoves;\r\n\r\n\t// Change the board state\r\n\tlet movedPiece = newBoard[move.fromSquare];\r\n\tnewBoard[move.fromSquare] = null;\r\n\tnewBoard[move.toSquare] = movedPiece;\r\n\r\n\t// Check if move is pawn move or capture for the half move clock\r\n\tlet isPawnMoveOrCapture: boolean = false;\r\n\tif (gameState.boardState[move.toSquare] != null) {\r\n\t\tisPawnMoveOrCapture = true;\r\n\t}\r\n\r\n\t// Check for castling\r\n\tif (gameState.boardState[move.fromSquare]?.type === PieceType.King) {\r\n\t\t// Move the rook if castling\r\n\t\tlet rookMove: Move | undefined = isMoveCastling(move);\r\n\t\tif (rookMove) {\r\n\t\t\tlet rook = newBoard[rookMove.fromSquare];\r\n\t\t\tnewBoard[rookMove.fromSquare] = null;\r\n\t\t\tnewBoard[rookMove.toSquare] = rook;\r\n\t\t}\r\n\r\n\t\t// Remove castling rights if king has moved\r\n\t\tif (gameState.currentPlayer === Color.White) {\r\n\t\t\tnewCastlingRights.whiteShort = false;\r\n\t\t\tnewCastlingRights.whiteLong = false;\r\n\t\t} else {\r\n\t\t\tnewCastlingRights.blackShort = false;\r\n\t\t\tnewCastlingRights.blackLong = false;\r\n\t\t}\r\n\t}\r\n\r\n\t// Remove castling rights if rook moved\r\n\tif (gameState.boardState[move.fromSquare]?.type === PieceType.Rook) {\r\n\t\tif (gameState.currentPlayer === Color.White) {\r\n\t\t\tif (move.fromSquare === 0) {\r\n\t\t\t\tnewCastlingRights.whiteLong = false;\r\n\t\t\t} else if (move.fromSquare === 7) {\r\n\t\t\t\tnewCastlingRights.whiteShort = false;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (move.fromSquare === 56) {\r\n\t\t\t\tnewCastlingRights.blackLong = false;\r\n\t\t\t} else if (move.fromSquare === 63) {\r\n\t\t\t\tnewCastlingRights.blackShort = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Remove castling rights if rook taken\r\n\tif (gameState.boardState[move.toSquare]?.type === PieceType.Rook) {\r\n\t\tif (gameState.boardState[move.toSquare]?.color === Color.White) {\r\n\t\t\tif (move.toSquare === 0) {\r\n\t\t\t\tnewCastlingRights.whiteLong = false;\r\n\t\t\t} else if (move.toSquare === 7) {\r\n\t\t\t\tnewCastlingRights.whiteShort = false;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (move.toSquare === 56) {\r\n\t\t\t\tnewCastlingRights.blackLong = false;\r\n\t\t\t} else if (move.toSquare === 63) {\r\n\t\t\t\tnewCastlingRights.blackShort = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Change current player, but only if a pawn hasn't moved to a promotion square\r\n\tif (!isMovePromotion(move, gameState.boardState)) {\r\n\t\tif (gameState.currentPlayer === Color.White) {\r\n\t\t\tnewCurrentPlayer = Color.Black;\r\n\t\t} else {\r\n\t\t\tnewCurrentPlayer = Color.White;\r\n\t\t\t// If the move was black's increment the full move counter\r\n\t\t\tnewFullMoves++;\r\n\t\t}\r\n\t} else if (gameState.currentPlayer == Color.Black) {\r\n\t\tnewBoard = promotePawn(\r\n\t\t\t{ ...gameState, boardState: newBoard },\r\n\t\t\tmove.toSquare,\r\n\t\t\tPieceType.Queen\r\n\t\t).boardState;\r\n\t\tnewCurrentPlayer = Color.White;\r\n\t\t// If the move was black's increment the full move counter\r\n\t\tnewFullMoves++;\r\n\t}\r\n\r\n\t// Check for en passant opportunity (only if a pawn has moved twice this turn)\r\n\tif (gameState.boardState[move.fromSquare]?.type === PieceType.Pawn) {\r\n\t\tif (\r\n\t\t\tMath.abs(\r\n\t\t\t\tMath.floor(move.fromSquare / 8) - Math.floor(move.toSquare / 8)\r\n\t\t\t) === 2\r\n\t\t) {\r\n\t\t\tnewEnPassantSquare =\r\n\t\t\t\tmove.toSquare +\r\n\t\t\t\t8 *\r\n\t\t\t\t\t(gameState.boardState[move.fromSquare]?.color === Color.White\r\n\t\t\t\t\t\t? -1\r\n\t\t\t\t\t\t: 1);\r\n\t\t}\r\n\r\n\t\tisPawnMoveOrCapture = true;\r\n\t}\r\n\r\n\t// Increment the half move clock if the move wasnt pawn move or a capture\r\n\tif (isPawnMoveOrCapture === false) newHalfMoveClock++;\r\n\telse newHalfMoveClock = 0;\r\n\r\n\tlet newGameState: GameState = {\r\n\t\tboardState: newBoard,\r\n\t\tcastlingRights: newCastlingRights,\r\n\t\tcurrentPlayer: newCurrentPlayer,\r\n\t\tenPassantSquare: newEnPassantSquare,\r\n\t\thalfMoveClock: newHalfMoveClock,\r\n\t\tfullMoves: newFullMoves,\r\n\t};\r\n\r\n\treturn newGameState;\r\n};\r\n\r\n/* \r\n  Checks if the given move is castling\r\n  Returns the rook move for castling or undefined\r\n*/\r\nexport const isMoveCastling = (move: Move): Move | undefined => {\r\n\tif (move.toSquare === move.fromSquare + 2)\r\n\t\treturn {\r\n\t\t\tfromSquare: move.toSquare + 1,\r\n\t\t\ttoSquare: move.toSquare - 1,\r\n\t\t};\r\n\r\n\tif (move.toSquare === move.fromSquare - 2)\r\n\t\treturn {\r\n\t\t\tfromSquare: move.toSquare - 2,\r\n\t\t\ttoSquare: move.toSquare + 1,\r\n\t\t};\r\n\r\n\treturn undefined;\r\n};\r\n\r\n/*\r\n\tCheck if the move is a promotion and returns a boolean\r\n*/\r\nexport const isMovePromotion = (\r\n\tmove: Move,\r\n\tboardState: (Piece | null)[]\r\n): boolean => {\r\n\tif (boardState[move.fromSquare]?.type == PieceType.Pawn) {\r\n\t\t// If white pawn is on the 8th rank\r\n\t\tif (\r\n\t\t\tboardState[move.fromSquare]?.color == Color.White &&\r\n\t\t\tMath.floor(move.toSquare / 8) == 7\r\n\t\t) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// If black pawn is on the 1st rank\r\n\t\tif (\r\n\t\t\tboardState[move.fromSquare]?.color == Color.Black &&\r\n\t\t\tMath.floor(move.toSquare / 8) == 0\r\n\t\t) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n/*\r\n\tCheck if the piece is a rook, bishop or queen\r\n*/\r\nconst isSlidingPiece = (piece: PieceType): boolean => {\r\n\treturn (\r\n\t\tpiece === PieceType.Bishop ||\r\n\t\tpiece === PieceType.Rook ||\r\n\t\tpiece === PieceType.Queen\r\n\t);\r\n};\r\n\r\n/*\r\n\tPromotes a pawn and advances the turn to the next player\r\n*/\r\nexport const promotePawn = (\r\n\tgameState: GameState,\r\n\tpawnSquare: number,\r\n\tpromoteTo: PieceType\r\n): GameState => {\r\n\tlet newBoard: (Piece | null)[] = [...gameState.boardState];\r\n\tlet newCurrentPlayer: Color = gameState.currentPlayer;\r\n\tlet newFullMoves: number = gameState.fullMoves;\r\n\r\n\t// Update the board state\r\n\tif (newBoard[pawnSquare] != null) {\r\n\t\tnewBoard[pawnSquare] = {\r\n\t\t\tcolor: newBoard[pawnSquare]!.color,\r\n\t\t\ttype: promoteTo,\r\n\t\t};\r\n\t}\r\n\r\n\t// Change the current player\r\n\tif (gameState.currentPlayer === Color.White) {\r\n\t\tnewCurrentPlayer = Color.Black;\r\n\t} else {\r\n\t\tnewCurrentPlayer = Color.White;\r\n\t\t// If the move was black's increment the full move counter\r\n\t\tnewFullMoves++;\r\n\t}\r\n\r\n\tconst newGameState: GameState = {\r\n\t\t...gameState,\r\n\t\tboardState: newBoard,\r\n\t\tcurrentPlayer: newCurrentPlayer,\r\n\t\tfullMoves: newFullMoves,\r\n\t};\r\n\r\n\treturn newGameState;\r\n};\r\n\r\n/*\r\n\tTransfors a FEN string into the GameState object\r\n*/\r\nexport const gameStateFromFEN = (fen: string): GameState => {\r\n\tlet newBoard: (Piece | null)[] = [];\r\n\tlet newCastlingRights: CastlingRights = {\r\n\t\twhiteShort: false,\r\n\t\twhiteLong: false,\r\n\t\tblackShort: false,\r\n\t\tblackLong: false,\r\n\t};\r\n\tlet newCurrentPlayer: Color;\r\n\tlet newEnPassantSquare: number | null = null;\r\n\tlet newHalfMoveClock: number;\r\n\tlet newFullMoves: number;\r\n\r\n\tconst symbolToPiece = (symbol: string): PieceType => {\r\n\t\tswitch (symbol.toLowerCase()) {\r\n\t\t\tcase \"p\":\r\n\t\t\t\treturn PieceType.Pawn;\r\n\t\t\tcase \"r\":\r\n\t\t\t\treturn PieceType.Rook;\r\n\t\t\tcase \"n\":\r\n\t\t\t\treturn PieceType.Knight;\r\n\t\t\tcase \"b\":\r\n\t\t\t\treturn PieceType.Bishop;\r\n\t\t\tcase \"q\":\r\n\t\t\t\treturn PieceType.Queen;\r\n\t\t\tcase \"k\":\r\n\t\t\t\treturn PieceType.King;\r\n\t\t\tdefault:\r\n\t\t\t\treturn PieceType.King;\r\n\t\t}\r\n\t};\r\n\r\n\tconst fenArray: string[] = fen.split(\" \");\r\n\r\n\t// Board representation\r\n\tlet fenBoard = fenArray[0];\r\n\tlet file = 0;\r\n\tlet rank = 7;\r\n\r\n\tfor (let symbol of fenBoard) {\r\n\t\tif (symbol === \"/\") {\r\n\t\t\tfile = 0;\r\n\t\t\trank--;\r\n\t\t} else {\r\n\t\t\tif (!isNaN(parseInt(symbol))) {\r\n\t\t\t\tfor (let i = 0; i < parseInt(symbol); i++)\r\n\t\t\t\t\tnewBoard[file + i + rank * 8] = null;\r\n\t\t\t\tfile += parseInt(symbol);\r\n\t\t\t} else {\r\n\t\t\t\tlet piece: Piece = {\r\n\t\t\t\t\ttype: symbolToPiece(symbol),\r\n\t\t\t\t\tcolor: symbol === symbol.toUpperCase() ? Color.White : Color.Black,\r\n\t\t\t\t};\r\n\t\t\t\tnewBoard[file + 8 * rank] = piece;\r\n\t\t\t\tfile++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Current player\r\n\tlet fenPlayer = fenArray[1];\r\n\r\n\tif (fenPlayer === \"w\") newCurrentPlayer = Color.White;\r\n\telse newCurrentPlayer = Color.Black;\r\n\r\n\t// Castling rights\r\n\tlet fenCastling = fenArray[2];\r\n\r\n\tif (fenCastling.includes(\"K\")) newCastlingRights.whiteShort = true;\r\n\tif (fenCastling.includes(\"Q\")) newCastlingRights.whiteLong = true;\r\n\tif (fenCastling.includes(\"k\")) newCastlingRights.blackShort = true;\r\n\tif (fenCastling.includes(\"q\")) newCastlingRights.blackLong = true;\r\n\r\n\t// En passant square\r\n\tlet fenPassant = fenArray[3];\r\n\r\n\tif (fenPassant !== \"-\") {\r\n\t\tlet fileString = fenPassant[0];\r\n\t\tlet rankString = fenPassant[1];\r\n\r\n\t\tnewEnPassantSquare =\r\n\t\t\tfileString.charCodeAt(0) - 65 + parseInt(rankString) * 8;\r\n\t}\r\n\r\n\t// Half move clock\r\n\tlet fenHalfMove = fenArray[4];\r\n\r\n\tnewHalfMoveClock = parseInt(fenHalfMove);\r\n\r\n\t// Full move clock\r\n\tlet fenFullMoves = fenArray[5];\r\n\r\n\tnewFullMoves = parseInt(fenFullMoves);\r\n\r\n\tlet newGameState: GameState = {\r\n\t\tboardState: newBoard,\r\n\t\tcastlingRights: newCastlingRights,\r\n\t\tcurrentPlayer: newCurrentPlayer,\r\n\t\tenPassantSquare: newEnPassantSquare,\r\n\t\thalfMoveClock: newHalfMoveClock,\r\n\t\tfullMoves: newFullMoves,\r\n\t};\r\n\r\n\treturn newGameState;\r\n};\r\n\r\n/*\r\n\tTransforms the game state into a FEN string\r\n*/\r\nexport const FENFromGameState = ({\r\n\tboardState,\r\n\tcurrentPlayer,\r\n\tcastlingRights,\r\n\tenPassantSquare,\r\n\thalfMoveClock,\r\n\tfullMoves,\r\n}: GameState): string => {\r\n\tlet fenString: string = \"\";\r\n\r\n\tconst pieceToSymbol = (piece: Piece | null): string => {\r\n\t\tlet symbol: string = \"\";\r\n\r\n\t\tif (piece == null) return symbol;\r\n\r\n\t\tswitch (piece.type) {\r\n\t\t\tcase PieceType.Pawn: {\r\n\t\t\t\tsymbol = \"p\";\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase PieceType.Rook: {\r\n\t\t\t\tsymbol = \"r\";\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase PieceType.Knight: {\r\n\t\t\t\tsymbol = \"n\";\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase PieceType.Bishop: {\r\n\t\t\t\tsymbol = \"b\";\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase PieceType.Queen: {\r\n\t\t\t\tsymbol = \"q\";\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase PieceType.King: {\r\n\t\t\t\tsymbol = \"k\";\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (piece.color === Color.White) symbol = symbol.toUpperCase();\r\n\r\n\t\treturn symbol;\r\n\t};\r\n\r\n\tlet file = 0;\r\n\tlet rank = 7;\r\n\r\n\t// Board state\r\n\tfor (let rankIndex = rank; rankIndex >= 0; rankIndex--) {\r\n\t\tlet emptySquares = 0;\r\n\t\tfor (let fileIndex = file; fileIndex < 8; fileIndex++) {\r\n\t\t\tif (boardState[fileIndex + 8 * rankIndex] == null) {\r\n\t\t\t\temptySquares++;\r\n\t\t\t} else {\r\n\t\t\t\tif (emptySquares > 0) {\r\n\t\t\t\t\tfenString += emptySquares.toString();\r\n\t\t\t\t}\r\n\t\t\t\tfenString += pieceToSymbol(boardState[fileIndex + 8 * rankIndex]);\r\n\t\t\t\temptySquares = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (emptySquares > 0) {\r\n\t\t\tfenString += emptySquares.toString();\r\n\t\t}\r\n\r\n\t\tif (rankIndex !== 0) fenString += \"/\";\r\n\t}\r\n\r\n\tfenString += \" \";\r\n\r\n\t// Current player\r\n\tfenString += currentPlayer === Color.White ? \"w\" : \"b\";\r\n\r\n\tfenString += \" \";\r\n\r\n\t// Castling rights\r\n\tfenString += castlingRights.whiteShort ? \"K\" : \"\";\r\n\tfenString += castlingRights.whiteLong ? \"Q\" : \"\";\r\n\tfenString += castlingRights.blackShort ? \"k\" : \"\";\r\n\tfenString += castlingRights.blackLong ? \"q\" : \"\";\r\n\r\n\tif (fenString[fenString.length - 1] === \" \") {\r\n\t\tfenString += \"-\";\r\n\t}\r\n\r\n\tfenString += \" \";\r\n\r\n\t// En passant square\r\n\tif (enPassantSquare == null) fenString += \"-\";\r\n\telse {\r\n\t\tlet enPassantFile = String.fromCharCode(\r\n\t\t\tenPassantSquare - Math.floor(enPassantSquare / 8) * 8 + 65\r\n\t\t);\r\n\t\tlet enPassantRank = Math.floor(enPassantSquare / 8) + 1;\r\n\r\n\t\tfenString += enPassantFile + enPassantRank;\r\n\t}\r\n\r\n\tfenString += \" \";\r\n\r\n\t// Half moves since last capture or pawn move and full move counter\r\n\tfenString += halfMoveClock + \" \" + fullMoves;\r\n\r\n\treturn fenString;\r\n};\r\n\r\n/*\r\n\tEvaluates material advantage of the board state\r\n\tPositive value means passed color is winning, ngative means the opponent is winning, zero is tied\r\n*/\r\nexport const evaluateMaterialAdvantage = (\r\n\tboardState: (Piece | null)[],\r\n\tside: Color\r\n): number => {\r\n\tconst piecePoints = {\r\n\t\t[PieceType.Pawn]: 100,\r\n\t\t[PieceType.Bishop]: 330,\r\n\t\t[PieceType.Knight]: 320,\r\n\t\t[PieceType.Rook]: 500,\r\n\t\t[PieceType.Queen]: 900,\r\n\t\t[PieceType.King]: 20000,\r\n\t};\r\n\tlet myScore = 0;\r\n\tlet opponentScore = 0;\r\n\r\n\t/* const whiteKing = boardState.indexOf(\r\n\t\tboardState.filter(\r\n\t\t\t(piece) => piece?.type === PieceType.King && piece.color === Color.White\r\n\t\t)[0]\r\n\t);\r\n\r\n\tconst blackKing = boardState.indexOf(\r\n\t\tboardState.filter(\r\n\t\t\t(piece) => piece?.type === PieceType.King && piece.color === Color.Black\r\n\t\t)[0]\r\n\t); */\r\n\r\n\tboardState.forEach((piece, index) => {\r\n\t\tif (!piece) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet table: number[] = [];\r\n\t\t// let enemyKing;\r\n\r\n\t\tif (piece.color === Color.White) {\r\n\t\t\t//enemyKing = blackKing;\r\n\t\t\tswitch (piece.type) {\r\n\t\t\t\tcase PieceType.Pawn:\r\n\t\t\t\t\ttable = pawnPSTableW;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.Bishop:\r\n\t\t\t\t\ttable = bishopPSTableW;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.Knight:\r\n\t\t\t\t\ttable = knightPSTableW;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.Rook:\r\n\t\t\t\t\ttable = rookPSTableW;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.Queen:\r\n\t\t\t\t\ttable = queenPSTableW;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.King:\r\n\t\t\t\t\ttable = kingPSTableW;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t//enemyKing = whiteKing;\r\n\t\t\tswitch (piece.type) {\r\n\t\t\t\tcase PieceType.Pawn:\r\n\t\t\t\t\ttable = pawnPSTableB;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.Bishop:\r\n\t\t\t\t\ttable = bishopPSTableB;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.Knight:\r\n\t\t\t\t\ttable = knightPSTableB;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.Rook:\r\n\t\t\t\t\ttable = rookPSTableB;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.Queen:\r\n\t\t\t\t\ttable = queenPSTableB;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase PieceType.King:\r\n\t\t\t\t\ttable = kingPSTableB;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst materialPoints = piecePoints[piece.type];\r\n\t\tconst positionPoints = table[index];\r\n\r\n\t\t//const kingProximityPoints = distanceToEnemyKing(enemyKing, index) * 60;\r\n\r\n\t\tif (piece?.color === side) {\r\n\t\t\tmyScore += materialPoints + positionPoints /*  + kingProximityPoints */;\r\n\t\t} else {\r\n\t\t\topponentScore +=\r\n\t\t\t\tmaterialPoints + positionPoints /* + kingProximityPoints */;\r\n\t\t}\r\n\t});\r\n\r\n\treturn myScore - opponentScore;\r\n};\r\n\r\nconst distanceToEnemyKing = (\r\n\tenemyKingPos: number,\r\n\tpiecePos: number\r\n): number => {\r\n\tconst oneOffsets = [8, -8, -1, 1, 7, -7, 9, -9];\r\n\tconst twoOffsets = [16, -16, -2, 2, 14, -14, 18, -18];\r\n\r\n\tif (oneOffsets.includes(piecePos - enemyKingPos)) {\r\n\t\treturn 2;\r\n\t} else if (twoOffsets.includes(piecePos - enemyKingPos)) {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\treturn 0;\r\n};\r\n","/** @jsxRuntime classic */\r\n/** @jsx jsx */\r\nimport { jsx } from \"@emotion/react\";\r\nimport React, { useState } from \"react\";\r\nimport styled from \"@emotion/styled\";\r\nimport { css } from \"@emotion/react\";\r\n\r\nimport { Piece, PieceType, Color, Move, GameState } from \"../interfaces\";\r\n\r\nimport { generateLegalMoves } from \"../GameLogic\";\r\n\r\ntype PropTypes = {\r\n\tgameState: GameState;\r\n\tlastMove: Move | null;\r\n\tonMakeMove: (move: Move) => void;\r\n};\r\n\r\nconst Board = ({ gameState, lastMove, onMakeMove }: PropTypes) => {\r\n\tconst [markedLegalMoveSquares, setMarkedLegalMoveSquares] = useState<\r\n\t\tnumber[]\r\n\t>([]);\r\n\r\n\tconst boardTiles: React.ReactNode = gameState.boardState.map(\r\n\t\t(piece, index) => {\r\n\t\t\treturn (\r\n\t\t\t\t<Square\r\n\t\t\t\t\tkey={index}\r\n\t\t\t\t\tisLight={\r\n\t\t\t\t\t\t!(Math.floor(index / 8) % 2 !== 0\r\n\t\t\t\t\t\t\t? index % 2 !== 0\r\n\t\t\t\t\t\t\t: index % 2 === 0)\r\n\t\t\t\t\t}\r\n\t\t\t\t\trow={8 - Math.floor(index / 8)}\r\n\t\t\t\t\timage={getImageForPiece(piece)}\r\n\t\t\t\t\tonDragOver={(e) => onDragOver(e)}\r\n\t\t\t\t\tonDrop={(e) => onDrop(e, index)}\r\n\t\t\t\t\tisMarkedLegal={markedLegalMoveSquares.includes(index)}\r\n\t\t\t\t\tisMarkedLastMove={\r\n\t\t\t\t\t\tlastMove?.fromSquare === index || lastMove?.toSquare === index\r\n\t\t\t\t\t}\r\n\t\t\t\t>\r\n\t\t\t\t\t<span\r\n\t\t\t\t\t\tstyle={{\r\n\t\t\t\t\t\t\tposition: \"absolute\",\r\n\t\t\t\t\t\t\ttop: \"0px\",\r\n\t\t\t\t\t\t\tleft: \"0px\",\r\n\t\t\t\t\t\t}}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t{index}\r\n\t\t\t\t\t</span>\r\n\t\t\t\t\t{piece ? (\r\n\t\t\t\t\t\tpiece.color === gameState.currentPlayer ? (\r\n\t\t\t\t\t\t\t<div\r\n\t\t\t\t\t\t\t\tdraggable\r\n\t\t\t\t\t\t\t\tonDragStart={(e) =>\r\n\t\t\t\t\t\t\t\t\tonDragStart(e, index, getImageForPiece(piece))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tonDragEnd={(e) => onDragEnd(e)}\r\n\t\t\t\t\t\t\t></div>\r\n\t\t\t\t\t\t) : (\r\n\t\t\t\t\t\t\t<div></div>\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) : null}\r\n\t\t\t\t</Square>\r\n\t\t\t);\r\n\t\t}\r\n\t);\r\n\r\n\tconst onDragOver = (e: React.DragEvent) => {\r\n\t\te.preventDefault();\r\n\t};\r\n\r\n\tconst onDragStart = async (\r\n\t\te: React.DragEvent,\r\n\t\ttilePos: number,\r\n\t\tpiece: string\r\n\t) => {\r\n\t\t(e.currentTarget as HTMLElement).style.opacity = \"0\";\r\n\t\te.dataTransfer.setData(\"tilePosition\", tilePos.toString());\r\n\t\tlet dragImage = new Image();\r\n\t\tdragImage.src = `${process.env.PUBLIC_URL}/images/${piece}.svg`;\r\n\r\n\t\te.dataTransfer.setDragImage(dragImage, 45, 45);\r\n\r\n\t\tlet allLegalMoves = generateLegalMoves(gameState);\r\n\r\n\t\tsetMarkedLegalMoveSquares(\r\n\t\t\tallLegalMoves\r\n\t\t\t\t.filter(({ fromSquare, toSquare }) => fromSquare === tilePos)\r\n\t\t\t\t.map(({ fromSquare, toSquare }) => toSquare)\r\n\t\t);\r\n\t};\r\n\r\n\tconst onDragEnd = (e: React.DragEvent) => {\r\n\t\t(e.currentTarget as HTMLElement).style.opacity = \"1\";\r\n\t\tsetMarkedLegalMoveSquares([]);\r\n\t};\r\n\r\n\tconst onDrop = (e: React.DragEvent, tilePosition: number) => {\r\n\t\tif (markedLegalMoveSquares.includes(tilePosition)) {\r\n\t\t\tlet move: Move = {\r\n\t\t\t\tfromSquare: parseInt(e.dataTransfer.getData(\"tilePosition\")),\r\n\t\t\t\ttoSquare: tilePosition,\r\n\t\t\t};\r\n\t\t\tonMakeMove(move);\r\n\t\t\tsetMarkedLegalMoveSquares([]);\r\n\t\t}\r\n\t};\r\n\r\n\treturn <Chessboard>{boardTiles}</Chessboard>;\r\n};\r\n\r\nconst Chessboard = styled.div`\r\n\twidth: 500px;\r\n\theight: 500px;\r\n\tbackground-color: green;\r\n\tdisplay: grid;\r\n\tgrid-template-columns: repeat(8, 1fr);\r\n\tgrid-template-rows: repeat(8, 1fr);\r\n\tposition: absolute;\r\n\ttop: 50%;\r\n\tleft: 50%;\r\n\ttransform: translate(-50%, -50%);\r\n`;\r\n\r\ntype SquareProps = {\r\n\trow: number;\r\n\tisLight: boolean;\r\n\tisMarkedLegal: boolean;\r\n\tisMarkedLastMove: boolean;\r\n\timage: string;\r\n};\r\n\r\nconst Square = styled.div<SquareProps>`\r\n\tposition: relative;\r\n\tdisplay: grid;\r\n\tplace-items: center;\r\n\tgrid-row: ${(props) => props.row};\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground-color: ${(props) => (props.isLight ? \"#f6edcd\" : \"#f0cf8e\")};\r\n\tcolor: black;\r\n\r\n\t::after {\r\n\t\tcontent: \"\";\r\n\t\tposition: absolute;\r\n\t\twidth: 85%;\r\n\t\theight: 85%;\r\n\t\tborder: 2px solid #5ca099;\r\n\t\topacity: ${(props) => (props.isMarkedLegal ? 1 : 0)};\r\n\t\tpointer-events: none;\r\n\t\tz-index: 2;\r\n\t}\r\n\r\n\t::before {\r\n\t\tcontent: \"\";\r\n\t\tposition: absolute;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t\tbackground-color: #a8c8a6;\r\n\t\topacity: ${(props) => (props.isMarkedLastMove ? 0.9 : 0)};\r\n\t\tpointer-events: none;\r\n\t\tz-index: 0;\r\n\t}\r\n\r\n\tdiv {\r\n\t\twidth: 80%;\r\n\t\theight: 80%;\r\n\t\tbackground-image: ${(props) =>\r\n\t\t\t`url(\"${process.env.PUBLIC_URL}/images/${props.image}.svg\")`};\r\n\t\tbackground-size: cover;\r\n\t\tz-index: 1;\r\n\t}\r\n`;\r\n\r\nconst getImageForPiece = (piece: Piece | null): string => {\r\n\tif (piece == null) return \"\";\r\n\tswitch (piece.type) {\r\n\t\tcase PieceType.King: {\r\n\t\t\tif (piece.color === Color.Black) return \"king_b\";\r\n\t\t\treturn \"king_w\";\r\n\t\t}\r\n\t\tcase PieceType.Queen: {\r\n\t\t\tif (piece.color === Color.Black) return \"queen_b\";\r\n\t\t\treturn \"queen_w\";\r\n\t\t}\r\n\t\tcase PieceType.Rook: {\r\n\t\t\tif (piece.color === Color.Black) return \"rook_b\";\r\n\t\t\treturn \"rook_w\";\r\n\t\t}\r\n\t\tcase PieceType.Bishop: {\r\n\t\t\tif (piece.color === Color.Black) return \"bishop_b\";\r\n\t\t\treturn \"bishop_w\";\r\n\t\t}\r\n\t\tcase PieceType.Knight: {\r\n\t\t\tif (piece.color === Color.Black) return \"knight_b\";\r\n\t\t\treturn \"knight_w\";\r\n\t\t}\r\n\t\tcase PieceType.Pawn: {\r\n\t\t\tif (piece.color === Color.Black) return \"pawn_b\";\r\n\t\t\treturn \"pawn_w\";\r\n\t\t}\r\n\t\tdefault:\r\n\t\t\treturn \"\";\r\n\t}\r\n};\r\n\r\nexport default Board;\r\n","/** @jsxRuntime classic */\r\n/** @jsx jsx */\r\nimport { jsx } from \"@emotion/react\";\r\nimport React, { useState } from \"react\";\r\nimport styled from \"@emotion/styled\";\r\n\r\nimport { GameState, Color } from \"../interfaces\";\r\n\r\nimport { FENFromGameState, evaluateMaterialAdvantage } from \"../GameLogic\";\r\n\r\ntype PropTypes = {\r\n\tgameState: GameState;\r\n};\r\n\r\nconst GameInfo = ({ gameState }: PropTypes) => {\r\n\treturn (\r\n\t\t<Wrapper>\r\n\t\t\t<p>\r\n\t\t\t\tCurrent player:{\" \"}\r\n\t\t\t\t{gameState.currentPlayer === Color.White ? \"white\" : \"black\"}\r\n\t\t\t</p>\r\n\t\t\t<div>\r\n\t\t\t\t<h3>Castling rights</h3>\r\n\t\t\t\t<h4>White</h4>\r\n\t\t\t\t<p>White king side: {gameState.castlingRights.whiteShort.toString()}</p>\r\n\t\t\t\t<p>White queen side: {gameState.castlingRights.whiteLong.toString()}</p>\r\n\t\t\t\t<h4>Black</h4>\r\n\t\t\t\t<p>Black king side: {gameState.castlingRights.blackShort.toString()}</p>\r\n\t\t\t\t<p>Black queen side: {gameState.castlingRights.blackLong.toString()}</p>\r\n\t\t\t</div>\r\n\t\t\t<div>\r\n\t\t\t\t<p>En passant square: {FENFromGameState(gameState).split(\" \")[3]}</p>\r\n\t\t\t</div>\r\n\t\t\t<div>\r\n\t\t\t\t<p>50 move rule counter: {gameState.halfMoveClock}</p>\r\n\t\t\t</div>\r\n\t\t\t<div>\r\n\t\t\t\t<p>Full moves: {gameState.fullMoves}</p>\r\n\t\t\t</div>\r\n\t\t\t<p>\r\n\t\t\t\tMaterial advantage:{\" \"}\r\n\t\t\t\t{evaluateMaterialAdvantage(gameState.boardState, Color.White)}\r\n\t\t\t</p>\r\n\t\t</Wrapper>\r\n\t);\r\n};\r\n\r\nconst Wrapper = styled.aside`\r\n\tpadding: 10px;\r\n\tbackground-color: rgba(0, 0, 0, 0.2);\r\n\r\n\tdiv {\r\n\t\tmargin: 10px 0;\r\n\t}\r\n`;\r\n\r\nexport default GameInfo;\r\n","/** @jsxRuntime classic */\r\n/** @jsx jsx */\r\nimport { jsx, keyframes } from \"@emotion/react\";\r\nimport React, { useState } from \"react\";\r\nimport styled from \"@emotion/styled\";\r\nimport { PieceType } from \"../interfaces\";\r\n\r\ntype PropTypes = {\r\n\tx: number;\r\n\ty: number;\r\n\tisShowing: boolean;\r\n\tonSelect: (selectedPiece: PieceType) => void;\r\n};\r\n\r\nconst PromotionModal = ({ x, y, isShowing, onSelect }: PropTypes) => {\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t{isShowing == true && (\r\n\t\t\t\t<Container>\r\n\t\t\t\t\t<button\r\n\t\t\t\t\t\tstyle={{ animationDelay: \"0s\" }}\r\n\t\t\t\t\t\tonClick={(e) => onSelect(PieceType.Queen)}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<img src={`${process.env.PUBLIC_URL}/images/queen_w.svg`} />\r\n\t\t\t\t\t</button>\r\n\t\t\t\t\t<button\r\n\t\t\t\t\t\tstyle={{ animationDelay: \"0.1s\" }}\r\n\t\t\t\t\t\tonClick={(e) => onSelect(PieceType.Rook)}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<img src={`${process.env.PUBLIC_URL}/images/rook_w.svg`} />\r\n\t\t\t\t\t</button>\r\n\t\t\t\t\t<button\r\n\t\t\t\t\t\tstyle={{ animationDelay: \"0.2s\" }}\r\n\t\t\t\t\t\tonClick={(e) => onSelect(PieceType.Bishop)}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<img src={`${process.env.PUBLIC_URL}/images/bishop_w.svg`} />\r\n\t\t\t\t\t</button>\r\n\t\t\t\t\t<button\r\n\t\t\t\t\t\tstyle={{ animationDelay: \"0.3s\" }}\r\n\t\t\t\t\t\tonClick={(e) => onSelect(PieceType.Knight)}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\t<img src={`${process.env.PUBLIC_URL}/images/knight_w.svg`} />\r\n\t\t\t\t\t</button>\r\n\t\t\t\t</Container>\r\n\t\t\t)}\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nconst appearAnimation = keyframes`\r\n\t0% {\r\n\t\ttransform: translateY(200px);\r\n\t\topacity: 0;\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0px);\r\n\t\topacity: 1;\r\n\t}\r\n`;\r\n\r\nconst Container = styled.div`\r\n\tposition: absolute;\r\n\tleft: 50%;\r\n\ttop: 50%;\r\n\ttransform: translate(-50%, -50%);\r\n\tdisplay: flex;\r\n\tflex-direction: row;\r\n\tcolumn-gap: 10px;\r\n\r\n\tbutton {\r\n\t\tpadding: 10px;\r\n\t\tbackground-color: #fff;\r\n\t\tborder-radius: 100%;\r\n\t\tbox-shadow: 0px 4px 16px rgba(0, 0, 0, 0.2);\r\n\t\topacity: 0;\r\n\t\tanimation: ${appearAnimation} 0.4s;\r\n\t\tanimation-fill-mode: forwards;\r\n\r\n\t\timg {\r\n\t\t\tdisplay: block;\r\n\t\t\twidth: 35px;\r\n\t\t\theight: 35px;\r\n\t\t\tobject-fit: contain;\r\n\t\t}\r\n\t}\r\n`;\r\n\r\nexport default PromotionModal;\r\n","/** @jsxRuntime classic */\r\n/** @jsx jsx */\r\nimport { jsx, keyframes } from \"@emotion/react\";\r\nimport React, { useState } from \"react\";\r\nimport styled from \"@emotion/styled\";\r\nimport { Color, PieceType } from \"../interfaces\";\r\n\r\ntype PropTypes = {\r\n\tx: number;\r\n\ty: number;\r\n\tisShowing: boolean;\r\n\twinner: Color | null;\r\n\tonRestart: () => void;\r\n};\r\n\r\nconst GameOverModal = ({ x, y, isShowing, winner, onRestart }: PropTypes) => {\r\n\treturn (\r\n\t\t<div\r\n\t\t\tstyle={{\r\n\t\t\t\tposition: \"absolute\",\r\n\t\t\t\tleft: \"50%\",\r\n\t\t\t\ttop: \"50%\",\r\n\t\t\t\ttransform: \"translate(-50%, -50%)\",\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t{isShowing == true && (\r\n\t\t\t\t<Container>\r\n\t\t\t\t\t<h3>{winner !== null ? \"Checkmate\" : \"Stalemate\"}</h3>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\t{winner !== null &&\r\n\t\t\t\t\t\t\t`Winner is ${winner === Color.White ? \"white\" : \"black\"}`}\r\n\t\t\t\t\t</p>\r\n\t\t\t\t\t<button\r\n\t\t\t\t\t\tstyle={{ animationDelay: \"0.3s\" }}\r\n\t\t\t\t\t\tonClick={(e) => {\r\n\t\t\t\t\t\t\tonRestart();\r\n\t\t\t\t\t\t}}\r\n\t\t\t\t\t>\r\n\t\t\t\t\t\tPlay again\r\n\t\t\t\t\t</button>\r\n\t\t\t\t</Container>\r\n\t\t\t)}\r\n\t\t</div>\r\n\t);\r\n};\r\n\r\nconst appearAnimation = keyframes`\r\n\t0% {\r\n\t\ttransform: translateY(200px);\r\n\t\topacity: 0;\r\n\t}\r\n\t100% {\r\n\t\ttransform: translateY(0px);\r\n\t\topacity: 1;\r\n\t}\r\n`;\r\n\r\nconst Container = styled.div`\r\n\tcolumn-gap: 10px;\r\n\tbackground-color: #fff;\r\n\tcolor: #000;\r\n\tpadding: 20px 60px;\r\n\ttext-align: center;\r\n\tborder-radius: 6px;\r\n\tbox-shadow: 0px 4px 32px rgba(0, 0, 0, 0.2);\r\n\topacity: 0;\r\n\tanimation: ${appearAnimation} 0.4s;\r\n\tanimation-fill-mode: forwards;\r\n\r\n\th3 {\r\n\t\tmargin-bottom: 10px;\r\n\t}\r\n\r\n\tp {\r\n\t\tmargin-bottom: 15px;\r\n\t}\r\n\r\n\tbutton {\r\n\t\tpadding: 15px 25px;\r\n\t\tbackground-color: #7ee654;\r\n\t\tfont-weight: bold;\r\n\t\tborder-radius: 6px;\r\n\t\tbox-shadow: 0px 4px 16px rgba(0, 0, 0, 0.2);\r\n\t}\r\n`;\r\n\r\nexport default GameOverModal;\r\n","/** @jsxRuntime classic */\n/** @jsx jsx */\nimport { jsx } from \"@emotion/react\";\nimport styled from \"@emotion/styled\";\nimport { useState, useEffect } from \"react\";\nimport useAsyncEffect from \"use-async-effect\";\n\nimport Board from \"./components/Board\";\nimport GameInfo from \"./components/GameInfo\";\n\nimport { Color, Move, GameState, PieceType, Piece } from \"./interfaces\";\nimport {\n\tmakeMove,\n\tgameStateFromFEN,\n\tpromotePawn,\n\tgenerateLegalMoves,\n\tgetKingAttacks,\n} from \"./GameLogic\";\nimport { getNegamaxMove, getAlphaBetaMove } from \"./AI\";\nimport PromotionModal from \"./components/PromotionModal\";\nimport GameOverModal from \"./components/GameOverModal\";\n\nconst startingFEN = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\n//const startingFEN = \"rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2 \";\n\nconst promotionFEN = \"k7/7P/8/8/8/8/p7/7K w - - 2 20\";\n\nconst checkFEN = \"8/2k2q2/8/5R2/2n5/5K2/8/8 w - - 2 20\";\n\nconst checkmateFEN = \"K7/8/1rq5/8/8/8/8/8 w - - 2 20\";\n\nconst whiteCheckmateFEN = \"k7/8/1R2Q3/8/8/8/8/8 w - - 2 20\";\n\nconst castleCheckFEN = \"8/q7/8/8/8/8/8/4K2R w KQkq - 2 20\";\n\nfunction App() {\n\tconst [gameState, setGameState] = useState<GameState>(\n\t\tgameStateFromFEN(startingFEN)\n\t);\n\tconst [lastMove, setLastMove] = useState<Move | null>(null);\n\tconst [isPromotionModalShowing, setIsPromotionModalShowing] = useState(false);\n\tconst [isGameOverModalShowing, setIsGameOverModalShowing] = useState(false);\n\tconst [winner, setWinner] = useState<Color | null>(null);\n\tconst [squareToPromote, setSquareToPromote] = useState<number | null>(null);\n\n\tuseEffect(() => {\n\t\t// Check for checkmate and stalemates\n\t\tconst responseMoves = generateLegalMoves(gameState);\n\t\tif (responseMoves.length === 0) {\n\t\t\tconst kingAttacks = getKingAttacks(gameState);\n\t\t\t// checkmate\n\t\t\tif (kingAttacks.length > 0) {\n\t\t\t\tsetWinner(\n\t\t\t\t\tgameState.currentPlayer == Color.White ? Color.Black : Color.White\n\t\t\t\t);\n\t\t\t}\n\t\t\t// stalemate, winner is null\n\t\t\tsetIsGameOverModalShowing(true);\n\t\t}\n\n\t\tif (gameState.currentPlayer === Color.Black) {\n\t\t\tlet computerMove: Move | undefined = getAlphaBetaMove(gameState);\n\t\t\tif (!computerMove) {\n\t\t\t\tsetIsGameOverModalShowing(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcallMakeMove(computerMove);\n\t\t}\n\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [gameState]);\n\n\tconst callMakeMove = (move: Move) => {\n\t\tconst newGameState = makeMove(gameState, move);\n\n\t\t// If new game state's current player is the same after making the move, the move is a promotion\n\t\tif (gameState.currentPlayer == newGameState.currentPlayer) {\n\t\t\tsetSquareToPromote(move.toSquare);\n\t\t\tsetIsPromotionModalShowing(true);\n\t\t}\n\n\t\tsetGameState(newGameState);\n\n\t\t// Set new last move\n\t\tsetLastMove(move);\n\t};\n\n\tconst handlePromotionSelect = (selectedPiece: PieceType): void => {\n\t\tif (squareToPromote == null) return;\n\t\tlet newGameState = promotePawn(gameState, squareToPromote, selectedPiece);\n\n\t\tsetGameState(newGameState);\n\t\tsetIsPromotionModalShowing(false);\n\t};\n\n\tconst restart = () => {\n\t\tsetGameState(gameStateFromFEN(startingFEN));\n\t\tsetLastMove(null);\n\t\tsetIsPromotionModalShowing(false);\n\t\tsetIsGameOverModalShowing(false);\n\t\tsetSquareToPromote(null);\n\t\tsetWinner(null);\n\t};\n\n\treturn (\n\t\t<Wrapper>\n\t\t\t<GameInfo gameState={gameState} />\n\t\t\t<Board\n\t\t\t\tgameState={gameState}\n\t\t\t\tlastMove={lastMove}\n\t\t\t\tonMakeMove={callMakeMove}\n\t\t\t/>\n\t\t\t<PromotionModal\n\t\t\t\tx={0}\n\t\t\t\ty={0}\n\t\t\t\tisShowing={isPromotionModalShowing}\n\t\t\t\tonSelect={handlePromotionSelect}\n\t\t\t/>\n\t\t\t<GameOverModal\n\t\t\t\tx={0}\n\t\t\t\ty={0}\n\t\t\t\tisShowing={isGameOverModalShowing}\n\t\t\t\twinner={winner}\n\t\t\t\tonRestart={restart}\n\t\t\t/>\n\t\t</Wrapper>\n\t);\n}\n\nconst Wrapper = styled.main`\n\tdisplay: grid;\n\tgrid-template-columns: 1fr 3fr 1fr;\n\tpadding: 40px;\n`;\n\nexport default App;\n","import {\r\n\tgenerateLegalMoves,\r\n\tgeneratePseudoLegalMoves,\r\n\tevaluateMaterialAdvantage,\r\n\tmakeMove,\r\n} from \"./GameLogic\";\r\nimport { Move, GameState, Color } from \"./interfaces\";\r\n\r\nexport const getRandomMove = async (gameState: GameState) => {\r\n\tlet legalMoves = generateLegalMoves(gameState);\r\n\r\n\tconst randomMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];\r\n\r\n\treturn randomMove;\r\n};\r\n\r\nexport const getNegamaxMove = (gameState: GameState) => {\r\n\tconst depth = 4;\r\n\tlet positionCounter: number = 0;\r\n\r\n\tconst negaMax = (gameState: GameState, depth: number): number => {\r\n\t\tpositionCounter++;\r\n\r\n\t\tif (depth === 0) {\r\n\t\t\treturn evaluateMaterialAdvantage(\r\n\t\t\t\tgameState.boardState,\r\n\t\t\t\tgameState.currentPlayer\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tlet max = Number.NEGATIVE_INFINITY;\r\n\t\tlet movesToEvaluate = generateLegalMoves(gameState);\r\n\t\tfor (const move of movesToEvaluate) {\r\n\t\t\tlet score: number = negaMax(makeMove(gameState, move), depth - 1) * -1;\r\n\t\t\tif (score > max) max = score;\r\n\t\t}\r\n\r\n\t\treturn max;\r\n\t};\r\n\r\n\tlet bestMovesWithScores: { move: Move; score: number }[] = [];\r\n\tlet bestMoveScore: number = Number.POSITIVE_INFINITY;\r\n\tlet allLegalMoves: Move[] = generateLegalMoves(gameState);\r\n\r\n\tif (allLegalMoves.length === 0) {\r\n\t\tconsole.log(\"Game over\");\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tlet startTime: number, endTime: number;\r\n\tstartTime = Date.now();\r\n\r\n\t// Get the best move relative to all the previous moves evaluated\r\n\tfor (const move of allLegalMoves) {\r\n\t\tlet moveScore: number = negaMax(makeMove(gameState, move), depth - 1);\r\n\t\tif (moveScore <= bestMoveScore) {\r\n\t\t\tbestMoveScore = moveScore;\r\n\t\t\tbestMovesWithScores.push({\r\n\t\t\t\tmove: move,\r\n\t\t\t\tscore: moveScore,\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t// Only keep the best moves\r\n\tbestMovesWithScores = bestMovesWithScores.filter(\r\n\t\t({ move, score }) => score === bestMoveScore\r\n\t);\r\n\r\n\tendTime = Date.now();\r\n\tlet timeDiff = endTime - startTime; //in ms\r\n\r\n\tconsole.log(\"Checking \" + positionCounter + \" moves\");\r\n\tconsole.log(\"That took \" + timeDiff + \"ms\");\r\n\r\n\tif (bestMovesWithScores.length === 0) return undefined;\r\n\r\n\treturn bestMovesWithScores[\r\n\t\tMath.floor(Math.random() * bestMovesWithScores.length)\r\n\t].move;\r\n};\r\n\r\nexport const getAlphaBetaMove = (gameState: GameState): Move | undefined => {\r\n\tconst depth = 3;\r\n\r\n\tlet positionCounter = 0;\r\n\r\n\tconst alphaBeta = (\r\n\t\tgameState: GameState,\r\n\t\talpha: number,\r\n\t\tbeta: number,\r\n\t\tdepth: number\r\n\t) => {\r\n\t\tpositionCounter++;\r\n\r\n\t\tif (depth == 0) {\r\n\t\t\treturn evaluateMaterialAdvantage(\r\n\t\t\t\tgameState.boardState,\r\n\t\t\t\tgameState.currentPlayer\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tlet movesToEvaluate = generateLegalMoves(gameState);\r\n\t\tfor (const move of movesToEvaluate) {\r\n\t\t\tlet score: number =\r\n\t\t\t\talphaBeta(makeMove(gameState, move), -1 * beta, -1 * alpha, depth - 1) *\r\n\t\t\t\t-1;\r\n\t\t\tif (score >= beta) return beta; //  fail hard beta-cutoff\r\n\t\t\tif (score > alpha) alpha = score; // alpha acts like max in MiniMax\r\n\t\t}\r\n\r\n\t\treturn alpha;\r\n\t};\r\n\r\n\tlet bestMovesWithScores: { move: Move; score: number }[] = [];\r\n\tlet bestMoveScore: number = Number.POSITIVE_INFINITY;\r\n\tlet allLegalMoves: Move[] = generateLegalMoves(gameState);\r\n\r\n\tlet startTime: number, endTime: number;\r\n\tstartTime = Date.now();\r\n\r\n\t// Get the best move relative to all the previous moves evaluated\r\n\tfor (const move of allLegalMoves) {\r\n\t\tlet moveScore: number = alphaBeta(\r\n\t\t\tmakeMove(gameState, move),\r\n\t\t\tNumber.NEGATIVE_INFINITY,\r\n\t\t\tNumber.POSITIVE_INFINITY,\r\n\t\t\tdepth\r\n\t\t);\r\n\t\tif (moveScore <= bestMoveScore) {\r\n\t\t\tbestMoveScore = moveScore;\r\n\t\t\tbestMovesWithScores.push({\r\n\t\t\t\tmove: move,\r\n\t\t\t\tscore: moveScore,\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t// Only keep the best moves\r\n\tbestMovesWithScores = bestMovesWithScores.filter(\r\n\t\t({ move, score }) => score === bestMoveScore\r\n\t);\r\n\r\n\tendTime = Date.now();\r\n\tlet timeDiff = endTime - startTime; //in ms\r\n\r\n\tconsole.log(\"Checking \" + positionCounter + \" moves\");\r\n\tconsole.log(\"That took \" + timeDiff + \"ms\");\r\n\r\n\tif (bestMovesWithScores.length == 0) {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\treturn bestMovesWithScores[\r\n\t\tMath.floor(Math.random() * bestMovesWithScores.length)\r\n\t].move;\r\n};\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\")\n);\n"],"sourceRoot":""}