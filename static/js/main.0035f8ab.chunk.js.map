{"version":3,"sources":["interfaces.ts","PrecomputedMoves.ts","GameLogic.ts","App.tsx","components/Board.tsx","AI.ts","index.tsx"],"names":["PieceType","Color","directionOffsets","numSquaresToEdge","rookMoves","kingMoves","knightMoves","pawnCapturesWhite","pawnCapturesBlack","squareIndex","y","Math","floor","x","north","south","west","east","min","directionIndex","currentDirOffset","n","targetSquare","push","fromSquare","toSquare","legalKingMoves","forEach","kingMoveDelta","kingMoveSquare","kingMoveSquareY","kingMoveSquareX","max","abs","legalKnightJumps","knightJumpDelta","knightJumpSquare","knightJumpSquareY","knightJumpSquareX","tempPawnCapturesWhite","tempPawnCapturesBlack","board","generatePseudoLegalMoves","boardState","sideColor","castlingRights","pseudoLegalMoves","pieces","map","piece","index","filter","color","type","Rook","Bishop","Queen","Knight","King","canCastleShort","White","whiteShort","blackShort","canCastleLong","whiteLong","blackLong","Pawn","doubleMoveSquare","startingRank","captureSquare","generateLegalMoves","legalMoves","move","boardAfterMove","makeVirtualMove","opponentResponses","Black","myKingSquare","indexOf","find","some","responseMove","tempBoardState","movedPiece","rookMove","isMoveCastling","rook","evaluateMaterialAdvantage","side","materialAdvantage","piecePoints","Chessboard","styled","div","Square","props","row","isLight","isMarked","image","getImageForPiece","Board","currentPlayer","onMakeMove","useState","markedLegalMoveSquares","setMarkedLegalMoveSquares","boardTiles","key","onDragOver","e","onDrop","includes","draggable","onDragStart","onDragEnd","preventDefault","tilePos","currentTarget","style","opacity","dataTransfer","setData","toString","dragImage","Image","src","setDragImage","allLegalMoves","tilePosition","parseInt","getData","getNegamaxMove","positionCounter","negaMax","currentBoardState","depth","Number","NEGATIVE_INFINITY","score","bestMovesWithScores","bestMoveScore","POSITIVE_INFINITY","length","startTime","Date","now","moveScore","timeDiff","console","log","random","fen","newBoard","symbolToPiece","symbol","toLowerCase","fenBoard","split","file","rank","isNaN","toUpperCase","i","positionFromFEN","InfoSection","App","setBoardState","setCurrentPlayer","setCastlingRights","useEffect","computerMakeMove","makeMove","draggedPiece","newCastlingRights","computerMove","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0035f8ab.chunk.js","sourcesContent":["export enum PieceType {\r\n\tKing,\r\n\tQueen,\r\n\tRook,\r\n\tBishop,\r\n\tKnight,\r\n\tPawn,\r\n}\r\n\r\nexport enum Color {\r\n\tWhite,\r\n\tBlack,\r\n}\r\n\r\nexport interface Piece {\r\n\ttype: PieceType;\r\n\tcolor: Color;\r\n}\r\n\r\nexport interface Move {\r\n\tfromSquare: number;\r\n\ttoSquare: number;\r\n}\r\n\r\nexport interface CastlingRights {\r\n\twhiteShort: boolean;\r\n\twhiteLong: boolean;\r\n\tblackShort: boolean;\r\n\tblackLong: boolean;\r\n}\r\n","import { Move } from \"./interfaces\";\r\n\r\n// First 4 are orthogonal, last 4 are diagonals (N, S, W, E, NW, SE, NE, SW)\r\nconst directionOffsets = [8, -8, -1, 1, 7, -7, 9, -9];\r\n\r\nlet numSquaresToEdge: [number[]] = [[]];\r\n\r\nlet rookMoves: Move[] = [];\r\nlet kingMoves: [number[]] = [[]];\r\nlet knightMoves: [number[]] = [[]];\r\nlet pawnCapturesWhite: [number[]] = [[]];\r\nlet pawnCapturesBlack: [number[]] = [[]];\r\n\r\nfor (let squareIndex = 0; squareIndex < 64; squareIndex++) {\r\n\tlet y: number = Math.floor(squareIndex / 8);\r\n\tlet x: number = squareIndex - y * 8;\r\n\r\n\tlet north: number = 7 - y;\r\n\tlet south: number = y;\r\n\tlet west: number = x;\r\n\tlet east: number = 7 - x;\r\n\r\n\tnumSquaresToEdge[squareIndex] = [];\r\n\r\n\tnumSquaresToEdge[squareIndex][0] = north;\r\n\tnumSquaresToEdge[squareIndex][1] = south;\r\n\tnumSquaresToEdge[squareIndex][2] = west;\r\n\tnumSquaresToEdge[squareIndex][3] = east;\r\n\tnumSquaresToEdge[squareIndex][4] = Math.min(north, west);\r\n\tnumSquaresToEdge[squareIndex][5] = Math.min(south, east);\r\n\tnumSquaresToEdge[squareIndex][6] = Math.min(north, east);\r\n\tnumSquaresToEdge[squareIndex][7] = Math.min(south, west);\r\n\r\n\t// Rook moves\r\n\tfor (let directionIndex = 0; directionIndex < 4; directionIndex++) {\r\n\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\tfor (let n = 0; n < numSquaresToEdge[squareIndex][directionIndex]; n++) {\r\n\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\t\t\trookMoves.push({ fromSquare: squareIndex, toSquare: targetSquare });\r\n\t\t}\r\n\t}\r\n\r\n\t// King moves\r\n\tlet legalKingMoves: number[] = [];\r\n\tdirectionOffsets.forEach((kingMoveDelta) => {\r\n\t\tlet kingMoveSquare: number = squareIndex + kingMoveDelta;\r\n\t\t// Check only moves within the bounds of the board\r\n\t\tif (kingMoveSquare >= 0 && kingMoveSquare < 64) {\r\n\t\t\tlet kingMoveSquareY = Math.floor(kingMoveSquare / 8);\r\n\t\t\tlet kingMoveSquareX = kingMoveSquare - kingMoveSquareY * 8;\r\n\t\t\t// Save only moves that didn't wrap around the board (where max move distance in any direction is 1)\r\n\t\t\tlet maxMoveDistance = Math.max(\r\n\t\t\t\tMath.abs(x - kingMoveSquareX),\r\n\t\t\t\tMath.abs(y - kingMoveSquareY)\r\n\t\t\t);\r\n\t\t\tif (maxMoveDistance == 1) {\r\n\t\t\t\tlegalKingMoves.push(kingMoveSquare);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tkingMoves[squareIndex] = legalKingMoves;\r\n\r\n\t// Knight moves\r\n\tconst allKnightJumps: number[] = [15, 17, -17, -15, 10, -6, 6, -10];\r\n\tlet legalKnightJumps: number[] = [];\r\n\tallKnightJumps.forEach((knightJumpDelta) => {\r\n\t\tlet knightJumpSquare = squareIndex + knightJumpDelta;\r\n\t\t// Check only moves within the bounds of the board\r\n\t\tif (knightJumpSquare >= 0 && knightJumpSquare < 64) {\r\n\t\t\tlet knightJumpSquareY = Math.floor(knightJumpSquare / 8);\r\n\t\t\tlet knightJumpSquareX = knightJumpSquare - knightJumpSquareY * 8;\r\n\t\t\t// Save only moves that didn't wrap around the board (where max move distance in any direction is 2)\r\n\t\t\tlet maxMoveDistance = Math.max(\r\n\t\t\t\tMath.abs(x - knightJumpSquareX),\r\n\t\t\t\tMath.abs(y - knightJumpSquareY)\r\n\t\t\t);\r\n\t\t\tif (maxMoveDistance == 2) {\r\n\t\t\t\tlegalKnightJumps.push(knightJumpSquare);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tknightMoves[squareIndex] = legalKnightJumps;\r\n\r\n\t// Pawn captures\r\n\t// Calculate legal pawn captures for white and black\r\n\tlet tempPawnCapturesWhite: number[] = [];\r\n\tlet tempPawnCapturesBlack: number[] = [];\r\n\tif (x > 0) {\r\n\t\tif (y < 7) {\r\n\t\t\ttempPawnCapturesWhite.push(squareIndex + 7);\r\n\t\t}\r\n\t\tif (y > 0) {\r\n\t\t\ttempPawnCapturesBlack.push(squareIndex - 9);\r\n\t\t}\r\n\t}\r\n\tif (x < 7) {\r\n\t\tif (y < 7) {\r\n\t\t\ttempPawnCapturesWhite.push(squareIndex + 9);\r\n\t\t}\r\n\t\tif (y > 0) {\r\n\t\t\ttempPawnCapturesBlack.push(squareIndex - 7);\r\n\t\t}\r\n\t}\r\n\r\n\tpawnCapturesWhite[squareIndex] = tempPawnCapturesWhite;\r\n\tpawnCapturesBlack[squareIndex] = tempPawnCapturesBlack;\r\n}\r\n\r\nexport {\r\n\tnumSquaresToEdge,\r\n\trookMoves,\r\n\tkingMoves,\r\n\tknightMoves,\r\n\tpawnCapturesBlack,\r\n\tpawnCapturesWhite,\r\n};\r\n","import { Move, Piece, Color, PieceType, CastlingRights } from \"./interfaces\";\r\nimport {\r\n\tnumSquaresToEdge,\r\n\tkingMoves,\r\n\tknightMoves,\r\n\tpawnCapturesWhite,\r\n\tpawnCapturesBlack,\r\n} from \"./PrecomputedMoves\";\r\n\r\n/*\r\n\tGenerates moves without check detection\r\n\tReturns a list of all pesudo legal moves\r\n*/\r\nexport const generatePseudoLegalMoves = (\r\n\tboardState: (Piece | null)[],\r\n\tsideColor: Color,\r\n\tcastlingRights: CastlingRights\r\n): Move[] => {\r\n\tlet pseudoLegalMoves: Move[] = [];\r\n\r\n\tlet pieces: [Piece | null, number][] = boardState.map((piece, index) => [\r\n\t\tpiece,\r\n\t\tindex,\r\n\t]);\r\n\tpieces = pieces.filter(([piece, index]) => piece?.color == sideColor);\r\n\r\n\t// First 4 are orthogonal, last 4 are diagonals (N, S, W, E, NW, SE, NE, SW)\r\n\tconst directionOffsets = [8, -8, -1, 1, 7, -7, 9, -9];\r\n\r\n\tpieces.forEach(([piece, squareIndex]) => {\r\n\t\tswitch (piece?.type) {\r\n\t\t\tcase PieceType.Rook: {\r\n\t\t\t\tfor (let directionIndex = 0; directionIndex < 4; directionIndex++) {\r\n\t\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\t\tfor (\r\n\t\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\t\tn++\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\t\tif (boardState[targetSquare]?.color == sideColor) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tboardState[targetSquare] != null &&\r\n\t\t\t\t\t\t\tboardState[targetSquare]?.color != sideColor\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.Bishop: {\r\n\t\t\t\tfor (let directionIndex = 4; directionIndex < 8; directionIndex++) {\r\n\t\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\t\tfor (\r\n\t\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\t\tn++\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\t\tif (boardState[targetSquare]?.color == sideColor) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tboardState[targetSquare] != null &&\r\n\t\t\t\t\t\t\tboardState[targetSquare]?.color != sideColor\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.Queen: {\r\n\t\t\t\tfor (let directionIndex = 0; directionIndex < 8; directionIndex++) {\r\n\t\t\t\t\tlet currentDirOffset = directionOffsets[directionIndex];\r\n\t\t\t\t\tfor (\r\n\t\t\t\t\t\tlet n = 0;\r\n\t\t\t\t\t\tn < numSquaresToEdge[squareIndex][directionIndex];\r\n\t\t\t\t\t\tn++\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tlet targetSquare = squareIndex + currentDirOffset * (n + 1);\r\n\r\n\t\t\t\t\t\t// Blocked by friendly piece, so stop looking in this direction\r\n\t\t\t\t\t\tif (boardState[targetSquare]?.color == sideColor) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t// Can caputure, so stop looking in this direction\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tboardState[targetSquare] != null &&\r\n\t\t\t\t\t\t\tboardState[targetSquare]?.color != sideColor\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.Knight: {\r\n\t\t\t\t// Find all knight moves from the piece's square\r\n\t\t\t\tlet allKnightMoves = knightMoves[squareIndex];\r\n\r\n\t\t\t\t// Filter out the moves that land on friendly pieces\r\n\t\t\t\tallKnightMoves.forEach((targetSquare) => {\r\n\t\t\t\t\tif (boardState[targetSquare]?.color != sideColor) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.King: {\r\n\t\t\t\t// Find all king moves from the piece's square\r\n\t\t\t\tlet allKingMoves = kingMoves[squareIndex];\r\n\r\n\t\t\t\t// Filter out the moves that land on friendly pieces\r\n\t\t\t\tallKingMoves.forEach((targetSquare) => {\r\n\t\t\t\t\tif (boardState[targetSquare]?.color != sideColor) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Castling\r\n\t\t\t\tconst canCastleShort =\r\n\t\t\t\t\tsideColor == Color.White\r\n\t\t\t\t\t\t? castlingRights.whiteShort\r\n\t\t\t\t\t\t: castlingRights.blackShort;\r\n\r\n\t\t\t\tconst canCastleLong =\r\n\t\t\t\t\tsideColor == Color.White\r\n\t\t\t\t\t\t? castlingRights.whiteLong\r\n\t\t\t\t\t\t: castlingRights.blackLong;\r\n\r\n\t\t\t\tif (canCastleShort) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tboardState[squareIndex + 1] == null &&\r\n\t\t\t\t\t\tboardState[squareIndex + 2] == null\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: squareIndex + 2,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (canCastleLong) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tboardState[squareIndex - 1] == null &&\r\n\t\t\t\t\t\tboardState[squareIndex - 2] == null\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: squareIndex - 2,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase PieceType.Pawn: {\r\n\t\t\t\t// Single moves\r\n\t\t\t\tlet targetSquare =\r\n\t\t\t\t\tpiece.color == Color.White ? squareIndex + 8 : squareIndex - 8;\r\n\r\n\t\t\t\tif (targetSquare >= 0 && targetSquare < 64) {\r\n\t\t\t\t\tif (boardState[targetSquare] == null)\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: targetSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Double first move\r\n\t\t\t\tlet doubleMoveSquare =\r\n\t\t\t\t\tpiece.color == Color.White ? squareIndex + 16 : squareIndex - 16;\r\n\t\t\t\tlet startingRank = piece.color == Color.White ? 1 : 6;\r\n\r\n\t\t\t\tif (Math.floor(squareIndex / 8) == startingRank) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tboardState[targetSquare] == null &&\r\n\t\t\t\t\t\tboardState[doubleMoveSquare] == null\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: doubleMoveSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Pawn captures\r\n\t\t\t\tlet pawnCaptures: number[] = [];\r\n\t\t\t\tif (piece.color == Color.White) {\r\n\t\t\t\t\tpawnCaptures = pawnCapturesWhite[squareIndex];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpawnCaptures = pawnCapturesBlack[squareIndex];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpawnCaptures.forEach((captureSquare) => {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tboardState[captureSquare]?.color != sideColor &&\r\n\t\t\t\t\t\tboardState[captureSquare] != null\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tpseudoLegalMoves.push({\r\n\t\t\t\t\t\t\tfromSquare: squareIndex,\r\n\t\t\t\t\t\t\ttoSquare: captureSquare,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t});\r\n\r\n\treturn pseudoLegalMoves;\r\n};\r\n\r\n/*\r\n\tGenerates the moves with check detecion by generating pseudo legal moves and removing illegal moves\r\n\tReturns a list of all legal moves\r\n*/\r\nexport const generateLegalMoves = (\r\n\tboardState: (Piece | null)[],\r\n\tsideColor: Color,\r\n\tcastlingRights: CastlingRights\r\n): Move[] => {\r\n\tlet legalMoves: Move[] = [];\r\n\tlet pseudoLegalMoves: Move[] = generatePseudoLegalMoves(\r\n\t\tboardState,\r\n\t\tsideColor,\r\n\t\tcastlingRights\r\n\t);\r\n\r\n\tpseudoLegalMoves.forEach((move) => {\r\n\t\tconst boardAfterMove = makeVirtualMove(boardState, move);\r\n\t\tconst opponentResponses = generatePseudoLegalMoves(\r\n\t\t\tboardAfterMove,\r\n\t\t\tsideColor == Color.White ? Color.Black : Color.White,\r\n\t\t\tcastlingRights\r\n\t\t);\r\n\r\n\t\tlet myKingSquare = boardAfterMove.indexOf(\r\n\t\t\tboardAfterMove.find(\r\n\t\t\t\t(piece) => piece?.type == PieceType.King && piece?.color == sideColor\r\n\t\t\t) || null\r\n\t\t);\r\n\r\n\t\tif (\r\n\t\t\topponentResponses.some(\r\n\t\t\t\t(responseMove) => responseMove.toSquare == myKingSquare\r\n\t\t\t)\r\n\t\t) {\r\n\t\t} else {\r\n\t\t\tlegalMoves.push(move);\r\n\t\t}\r\n\t});\r\n\r\n\treturn legalMoves;\r\n};\r\n\r\nexport const makeVirtualMove = (\r\n\tboardState: (Piece | null)[],\r\n\tmove: Move\r\n): (Piece | null)[] => {\r\n\tlet tempBoardState: (Piece | null)[] = [...boardState];\r\n\tlet movedPiece = tempBoardState[move.fromSquare];\r\n\ttempBoardState[move.fromSquare] = null;\r\n\ttempBoardState[move.toSquare] = movedPiece;\r\n\r\n\t// Check for castling\r\n\tif (boardState[move.fromSquare]?.type == PieceType.King) {\r\n\t\tlet rookMove: Move | undefined = isMoveCastling(move);\r\n\t\tif (rookMove) {\r\n\t\t\tlet rook = tempBoardState[rookMove.fromSquare];\r\n\t\t\ttempBoardState[rookMove.fromSquare] = null;\r\n\t\t\ttempBoardState[rookMove.toSquare] = rook;\r\n\t\t}\r\n\t}\r\n\r\n\treturn tempBoardState;\r\n};\r\n\r\n/* \r\n  Checks if the given move is castling\r\n  Returns the rook move for castling or undefined\r\n*/\r\nexport const isMoveCastling = (move: Move): Move | undefined => {\r\n\tif (move.toSquare == move.fromSquare + 2)\r\n\t\treturn {\r\n\t\t\tfromSquare: move.toSquare + 1,\r\n\t\t\ttoSquare: move.toSquare - 1,\r\n\t\t};\r\n\r\n\tif (move.toSquare == move.fromSquare - 2)\r\n\t\treturn {\r\n\t\t\tfromSquare: move.toSquare - 2,\r\n\t\t\ttoSquare: move.toSquare + 1,\r\n\t\t};\r\n\r\n\treturn undefined;\r\n};\r\n\r\n/*\r\n\tTransfors a FEN string into an array of Pieces and nulls representing the board\r\n*/\r\nexport const positionFromFEN = (fen: string): (Piece | null)[] => {\r\n\tlet newBoard: (Piece | null)[] = [];\r\n\r\n\tconst symbolToPiece = (symbol: string): PieceType => {\r\n\t\tswitch (symbol.toLowerCase()) {\r\n\t\t\tcase \"p\":\r\n\t\t\t\treturn PieceType.Pawn;\r\n\t\t\tcase \"r\":\r\n\t\t\t\treturn PieceType.Rook;\r\n\t\t\tcase \"n\":\r\n\t\t\t\treturn PieceType.Knight;\r\n\t\t\tcase \"b\":\r\n\t\t\t\treturn PieceType.Bishop;\r\n\t\t\tcase \"q\":\r\n\t\t\t\treturn PieceType.Queen;\r\n\t\t\tcase \"k\":\r\n\t\t\t\treturn PieceType.King;\r\n\t\t\tdefault:\r\n\t\t\t\treturn PieceType.King;\r\n\t\t}\r\n\t};\r\n\r\n\tconst fenBoard: string = fen.split(\" \")[0];\r\n\tlet file = 0;\r\n\tlet rank = 7;\r\n\r\n\tfor (let symbol of fenBoard) {\r\n\t\tif (symbol == \"/\") {\r\n\t\t\tfile = 0;\r\n\t\t\trank--;\r\n\t\t} else {\r\n\t\t\tif (!isNaN(parseInt(symbol))) {\r\n\t\t\t\tfor (let i = 0; i < parseInt(symbol); i++)\r\n\t\t\t\t\tnewBoard[file + i + rank * 8] = null;\r\n\t\t\t\tfile += parseInt(symbol);\r\n\t\t\t} else {\r\n\t\t\t\tlet piece: Piece = {\r\n\t\t\t\t\ttype: symbolToPiece(symbol),\r\n\t\t\t\t\tcolor: symbol == symbol.toUpperCase() ? Color.White : Color.Black,\r\n\t\t\t\t};\r\n\t\t\t\tnewBoard[file + 8 * rank] = piece;\r\n\t\t\t\tfile++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn newBoard;\r\n};\r\n\r\n/*\r\n\tEvaluates material advantage of the board state\r\n\tPositive value means white is winnin, negative means black is winning, zero is tied\r\n*/\r\nexport const evaluateMaterialAdvantage = (\r\n\tboardState: (Piece | null)[],\r\n\tside: Color\r\n): number => {\r\n\tlet materialAdvantage = 0;\r\n\r\n\tconst piecePoints = {\r\n\t\t[PieceType.Pawn]: 1,\r\n\t\t[PieceType.Bishop]: 3,\r\n\t\t[PieceType.Knight]: 3,\r\n\t\t[PieceType.Rook]: 5,\r\n\t\t[PieceType.Queen]: 9,\r\n\t\t[PieceType.King]: 900,\r\n\t};\r\n\r\n\tboardState.forEach((piece) => {\r\n\t\tif (piece) {\r\n\t\t\tmaterialAdvantage +=\r\n\t\t\t\tpiecePoints[piece.type] * (piece.color == Color.White ? 1 : -1);\r\n\t\t}\r\n\t});\r\n\r\n\treturn materialAdvantage * (side == Color.White ? 1 : -1);\r\n};\r\n","/** @jsxRuntime classic */\n/** @jsx jsx */\nimport { jsx } from \"@emotion/react\";\nimport styled from \"@emotion/styled\";\nimport React, { useState, useEffect } from \"react\";\n\nimport Board from \"./components/Board\";\n\nimport { Piece, PieceType, Color, Move, CastlingRights } from \"./interfaces\";\nimport {\n\tisMoveCastling,\n\tpositionFromFEN,\n\tevaluateMaterialAdvantage,\n} from \"./GameLogic\";\nimport { getNegamaxMove, getRandomMove } from \"./AI\";\n\nlet board: (Piece | null)[] = [];\n\n/* for (let file = 0; file < 8; file++) {\n\tfor (let rank = 0; rank < 8; rank++) {\n\t\tboard[file + 8 * rank] = null;\n\t}\n} */\n\nconst startingFEN = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\n\nboard = positionFromFEN(startingFEN);\n\nfunction App() {\n\tconst [boardState, setBoardState] = useState(board);\n\tconst [currentPlayer, setCurrentPlayer] = useState(Color.White);\n\tconst [castlingRights, setCastlingRights] = useState<CastlingRights>({\n\t\twhiteShort: true,\n\t\twhiteLong: true,\n\t\tblackShort: true,\n\t\tblackLong: true,\n\t});\n\n\tuseEffect(() => {\n\t\tif (currentPlayer == Color.Black) {\n\t\t\tcomputerMakeMove();\n\t\t}\n\t}, [currentPlayer]);\n\n\tconst makeMove = (move: Move) => {\n\t\tlet tempBoardState: (Piece | null)[] = [...boardState];\n\t\tlet draggedPiece = tempBoardState[move.fromSquare];\n\t\ttempBoardState[move.fromSquare] = null;\n\t\ttempBoardState[move.toSquare] = draggedPiece;\n\n\t\t// Check for castling\n\t\tif (boardState[move.fromSquare]?.type == PieceType.King) {\n\t\t\tlet rookMove: Move | undefined = isMoveCastling(move);\n\t\t\tif (rookMove) {\n\t\t\t\tlet rook = tempBoardState[rookMove.fromSquare];\n\t\t\t\ttempBoardState[rookMove.fromSquare] = null;\n\t\t\t\ttempBoardState[rookMove.toSquare] = rook;\n\t\t\t}\n\n\t\t\t// Remove castling rights if king has moved\n\t\t\tlet newCastlingRights = { ...castlingRights };\n\t\t\tif (currentPlayer == Color.White) {\n\t\t\t\tnewCastlingRights.whiteShort = false;\n\t\t\t\tnewCastlingRights.whiteLong = false;\n\t\t\t} else {\n\t\t\t\tnewCastlingRights.blackShort = false;\n\t\t\t\tnewCastlingRights.blackLong = false;\n\t\t\t}\n\n\t\t\tsetCastlingRights(newCastlingRights);\n\t\t}\n\n\t\t// Remove castling rights if rook moved\n\t\tif (boardState[move.fromSquare]?.type == PieceType.Rook) {\n\t\t\tlet newCastlingRights = { ...castlingRights };\n\t\t\tif (currentPlayer == Color.White) {\n\t\t\t\tif (move.fromSquare == 0) {\n\t\t\t\t\tnewCastlingRights.whiteLong = false;\n\t\t\t\t} else if (move.fromSquare == 7) {\n\t\t\t\t\tnewCastlingRights.whiteShort = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (move.fromSquare == 56) {\n\t\t\t\t\tnewCastlingRights.blackLong = false;\n\t\t\t\t} else if (move.fromSquare == 63) {\n\t\t\t\t\tnewCastlingRights.blackShort = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetCastlingRights(newCastlingRights);\n\t\t}\n\n\t\t// Remove castling rights if rook taken\n\t\tif (boardState[move.toSquare]?.type == PieceType.Rook) {\n\t\t\tlet newCastlingRights = { ...castlingRights };\n\t\t\tif (boardState[move.toSquare]?.color == Color.White) {\n\t\t\t\tif (move.toSquare == 0) {\n\t\t\t\t\tnewCastlingRights.whiteLong = false;\n\t\t\t\t} else if (move.toSquare == 7) {\n\t\t\t\t\tnewCastlingRights.whiteShort = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (move.toSquare == 56) {\n\t\t\t\t\tnewCastlingRights.blackLong = false;\n\t\t\t\t} else if (move.toSquare == 63) {\n\t\t\t\t\tnewCastlingRights.blackShort = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetCastlingRights(newCastlingRights);\n\t\t}\n\n\t\t// Change current player\n\t\tif (currentPlayer == Color.White) setCurrentPlayer(Color.Black);\n\t\telse setCurrentPlayer(Color.White);\n\t\t// Update board state\n\t\tsetBoardState(tempBoardState);\n\t};\n\n\tconst computerMakeMove = () => {\n\t\tlet computerMove = getNegamaxMove(boardState, castlingRights);\n\n\t\tif (!computerMove) return;\n\n\t\tmakeMove(computerMove);\n\t};\n\n\treturn (\n\t\t<main>\n\t\t\t<Board\n\t\t\t\tboardState={boardState}\n\t\t\t\tcurrentPlayer={currentPlayer}\n\t\t\t\tcastlingRights={castlingRights}\n\t\t\t\tonMakeMove={makeMove}\n\t\t\t/>\n\t\t\t<InfoSection>\n\t\t\t\t<p>\n\t\t\t\t\tCurrent player: {currentPlayer == Color.White ? \"white\" : \"black\"}\n\t\t\t\t</p>\n\t\t\t\t<p>\n\t\t\t\t\tMaterial advantage:{\" \"}\n\t\t\t\t\t{evaluateMaterialAdvantage(boardState, Color.White)}\n\t\t\t\t</p>\n\t\t\t</InfoSection>\n\t\t</main>\n\t);\n}\n\nconst InfoSection = styled.div`\n\tpadding: 50px;\n`;\n\nexport default App;\n","/** @jsxRuntime classic */\r\n/** @jsx jsx */\r\nimport React, { useState } from \"react\";\r\nimport { jsx } from \"@emotion/react\";\r\nimport styled from \"@emotion/styled\";\r\n\r\nimport { Piece, PieceType, Color, Move, CastlingRights } from \"../interfaces\";\r\n\r\nimport { generatePseudoLegalMoves, generateLegalMoves } from \"../GameLogic\";\r\n\r\ntype PropTypes = {\r\n\tboardState: (Piece | null)[];\r\n\tcurrentPlayer: Color;\r\n\tcastlingRights: CastlingRights;\r\n\tonMakeMove: (move: Move) => void;\r\n};\r\n\r\nconst Board = ({\r\n\tboardState,\r\n\tcurrentPlayer,\r\n\tcastlingRights,\r\n\tonMakeMove,\r\n}: PropTypes) => {\r\n\tconst [markedLegalMoveSquares, setMarkedLegalMoveSquares] = useState<\r\n\t\tnumber[]\r\n\t>([]);\r\n\r\n\tconst boardTiles: React.ReactNode = boardState.map((piece, index) => {\r\n\t\treturn (\r\n\t\t\t<Square\r\n\t\t\t\tkey={index}\r\n\t\t\t\tisLight={\r\n\t\t\t\t\t!(Math.floor(index / 8) % 2 != 0 ? index % 2 != 0 : index % 2 == 0)\r\n\t\t\t\t}\r\n\t\t\t\trow={8 - Math.floor(index / 8)}\r\n\t\t\t\timage={getImageForPiece(piece)}\r\n\t\t\t\tonDragOver={(e) => onDragOver(e)}\r\n\t\t\t\tonDrop={(e) => onDrop(e, index)}\r\n\t\t\t\tisMarked={markedLegalMoveSquares.includes(index)}\r\n\t\t\t>\r\n\t\t\t\t{piece ? (\r\n\t\t\t\t\tpiece.color == currentPlayer ? (\r\n\t\t\t\t\t\t<div\r\n\t\t\t\t\t\t\tdraggable\r\n\t\t\t\t\t\t\tonDragStart={(e) =>\r\n\t\t\t\t\t\t\t\tonDragStart(e, index, getImageForPiece(piece))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tonDragEnd={(e) => onDragEnd(e)}\r\n\t\t\t\t\t\t></div>\r\n\t\t\t\t\t) : (\r\n\t\t\t\t\t\t<div></div>\r\n\t\t\t\t\t)\r\n\t\t\t\t) : null}\r\n\t\t\t</Square>\r\n\t\t);\r\n\t});\r\n\r\n\tconst onDragOver = (e: React.DragEvent) => {\r\n\t\te.preventDefault();\r\n\t};\r\n\r\n\tconst onDragStart = (e: React.DragEvent, tilePos: number, piece: string) => {\r\n\t\t(e.currentTarget as HTMLElement).style.opacity = \"0\";\r\n\t\te.dataTransfer.setData(\"tilePosition\", tilePos.toString());\r\n\t\tlet dragImage = new Image();\r\n\t\tdragImage.src = `images/${piece}.svg`;\r\n\r\n\t\te.dataTransfer.setDragImage(dragImage, 45, 45);\r\n\r\n\t\tlet allLegalMoves = generateLegalMoves(\r\n\t\t\tboardState,\r\n\t\t\tcurrentPlayer,\r\n\t\t\tcastlingRights\r\n\t\t);\r\n\r\n\t\tsetMarkedLegalMoveSquares(\r\n\t\t\tallLegalMoves\r\n\t\t\t\t.filter(({ fromSquare, toSquare }) => fromSquare === tilePos)\r\n\t\t\t\t.map(({ fromSquare, toSquare }) => toSquare)\r\n\t\t);\r\n\t};\r\n\r\n\tconst onDragEnd = (e: React.DragEvent) => {\r\n\t\t(e.currentTarget as HTMLElement).style.opacity = \"1\";\r\n\t\tsetMarkedLegalMoveSquares([]);\r\n\t};\r\n\r\n\tconst onDrop = (e: React.DragEvent, tilePosition: number) => {\r\n\t\tif (markedLegalMoveSquares.includes(tilePosition)) {\r\n\t\t\tlet move: Move = {\r\n\t\t\t\tfromSquare: parseInt(e.dataTransfer.getData(\"tilePosition\")),\r\n\t\t\t\ttoSquare: tilePosition,\r\n\t\t\t};\r\n\t\t\tonMakeMove(move);\r\n\t\t\tsetMarkedLegalMoveSquares([]);\r\n\t\t}\r\n\t};\r\n\r\n\treturn <Chessboard>{boardTiles}</Chessboard>;\r\n};\r\n\r\nconst Chessboard = styled.div`\r\n\twidth: 500px;\r\n\theight: 500px;\r\n\tbackground-color: green;\r\n\tdisplay: grid;\r\n\tgrid-template-columns: repeat(8, 1fr);\r\n\tgrid-template-rows: repeat(8, 1fr);\r\n\tposition: absolute;\r\n\ttop: 50%;\r\n\tleft: 50%;\r\n\ttransform: translate(-50%, -50%);\r\n`;\r\n\r\ntype SquareProps = {\r\n\trow: number;\r\n\tisLight: boolean;\r\n\tisMarked: boolean;\r\n\timage: string;\r\n};\r\n\r\nconst Square = styled.div<SquareProps>`\r\n\tposition: relative;\r\n\tdisplay: grid;\r\n\tplace-items: center;\r\n\tgrid-row: ${(props) => props.row};\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground-color: ${(props) => (props.isLight ? \"#f6edcd\" : \"#f0cf8e\")};\r\n\tcolor: black;\r\n\r\n\t::after {\r\n\t\tcontent: \"\";\r\n\t\tposition: absolute;\r\n\t\twidth: 20%;\r\n\t\theight: 20%;\r\n\t\ttransform: rotate(45deg);\r\n\t\tbackground-color: #5ca099;\r\n\t\topacity: ${(props) => (props.isMarked ? 1 : 0)};\r\n\t\tpointer-events: none;\r\n\t}\r\n\r\n\tdiv {\r\n\t\twidth: 80%;\r\n\t\theight: 80%;\r\n\t\tbackground-image: ${(props) => `url(\"images/${props.image}.svg\")`};\r\n\t\tbackground-size: cover;\r\n\t}\r\n`;\r\n\r\nconst getImageForPiece = (piece: Piece | null): string => {\r\n\tif (piece == null) return \"\";\r\n\tswitch (piece.type) {\r\n\t\tcase PieceType.King: {\r\n\t\t\tif (piece.color == Color.Black) return \"king_b\";\r\n\t\t\treturn \"king_w\";\r\n\t\t}\r\n\t\tcase PieceType.Queen: {\r\n\t\t\tif (piece.color == Color.Black) return \"queen_b\";\r\n\t\t\treturn \"queen_w\";\r\n\t\t}\r\n\t\tcase PieceType.Rook: {\r\n\t\t\tif (piece.color == Color.Black) return \"rook_b\";\r\n\t\t\treturn \"rook_w\";\r\n\t\t}\r\n\t\tcase PieceType.Bishop: {\r\n\t\t\tif (piece.color == Color.Black) return \"bishop_b\";\r\n\t\t\treturn \"bishop_w\";\r\n\t\t}\r\n\t\tcase PieceType.Knight: {\r\n\t\t\tif (piece.color == Color.Black) return \"knight_b\";\r\n\t\t\treturn \"knight_w\";\r\n\t\t}\r\n\t\tcase PieceType.Pawn: {\r\n\t\t\tif (piece.color == Color.Black) return \"pawn_b\";\r\n\t\t\treturn \"pawn_w\";\r\n\t\t}\r\n\t\tdefault:\r\n\t\t\treturn \"\";\r\n\t}\r\n};\r\n\r\nexport default Board;\r\n","import {\r\n\tgenerateLegalMoves,\r\n\tgeneratePseudoLegalMoves,\r\n\tevaluateMaterialAdvantage,\r\n\tmakeVirtualMove,\r\n} from \"./GameLogic\";\r\nimport { Piece, PieceType, Color, Move, CastlingRights } from \"./interfaces\";\r\n\r\nexport const getRandomMove = (\r\n\tboardState: (Piece | null)[],\r\n\tcastlingRights: CastlingRights\r\n) => {\r\n\tlet legalMoves = generateLegalMoves(boardState, Color.Black, castlingRights);\r\n\r\n\tconst randomMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];\r\n\r\n\treturn randomMove;\r\n};\r\n\r\nexport const getNegamaxMove = (\r\n\tboardState: (Piece | null)[],\r\n\tcastlingRights: CastlingRights\r\n): Move | undefined => {\r\n\tlet positionCounter: number = 0;\r\n\r\n\tconst negaMax = (\r\n\t\tcurrentBoardState: (Piece | null)[],\r\n\t\tdepth: number,\r\n\t\tside: Color\r\n\t): number => {\r\n\t\tpositionCounter++;\r\n\r\n\t\tif (depth == 0) {\r\n\t\t\treturn evaluateMaterialAdvantage(currentBoardState, side);\r\n\t\t}\r\n\r\n\t\tlet max = Number.NEGATIVE_INFINITY;\r\n\t\tlet movesToEvaluate = generatePseudoLegalMoves(\r\n\t\t\tcurrentBoardState,\r\n\t\t\tside,\r\n\t\t\tcastlingRights\r\n\t\t);\r\n\t\tmovesToEvaluate.forEach((move) => {\r\n\t\t\tlet score = -negaMax(\r\n\t\t\t\tmakeVirtualMove(currentBoardState, move),\r\n\t\t\t\tdepth - 1,\r\n\t\t\t\tside == Color.White ? Color.Black : Color.White\r\n\t\t\t);\r\n\t\t\tif (score > max) max = score;\r\n\t\t});\r\n\r\n\t\treturn max;\r\n\t};\r\n\r\n\tlet bestMovesWithScores: { move: Move; score: number }[] = [];\r\n\tlet bestMoveScore: number = Number.POSITIVE_INFINITY;\r\n\tlet allLegalMoves: Move[] = generatePseudoLegalMoves(\r\n\t\tboardState,\r\n\t\tColor.Black,\r\n\t\tcastlingRights\r\n\t);\r\n\r\n\tif (allLegalMoves.length == 0) {\r\n\t\tconsole.log(\"Game over\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tlet startTime: number, endTime: number;\r\n\tstartTime = Date.now();\r\n\r\n\t// Get the best move relative to all the previous moves evaluated\r\n\tallLegalMoves.forEach((move) => {\r\n\t\tlet moveScore = negaMax(makeVirtualMove(boardState, move), 3, Color.White);\r\n\t\tif (moveScore <= bestMoveScore) {\r\n\t\t\tbestMoveScore = moveScore;\r\n\t\t\tbestMovesWithScores.push({\r\n\t\t\t\tmove: move,\r\n\t\t\t\tscore: moveScore,\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\r\n\t// Only keep the best moves\r\n\tbestMovesWithScores = bestMovesWithScores.filter(\r\n\t\t({ move, score }) => score == bestMoveScore\r\n\t);\r\n\r\n\tendTime = Date.now();\r\n\tlet timeDiff = endTime - startTime; //in ms\r\n\r\n\tconsole.log(\"Checking \" + positionCounter + \" moves\");\r\n\tconsole.log(\"That took \" + timeDiff + \"ms\");\r\n\r\n\tif (bestMovesWithScores.length == 0) return;\r\n\r\n\treturn bestMovesWithScores[\r\n\t\tMath.floor(Math.random() * bestMovesWithScores.length)\r\n\t].move;\r\n};\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\")\n);\n"],"sourceRoot":""}